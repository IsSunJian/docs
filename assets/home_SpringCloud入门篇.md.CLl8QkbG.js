import{_ as s,c as a,o as e,a4 as n}from"./chunks/framework.K9vKjHgL.js";const p="/docs/assets/image-20220529103635636.3lA7CBPW.png",l="/docs/assets/image-20220529104958819.n-0G4phR.png",o="/docs/assets/image-20220529105324554.B4vQJqI1.png",r="/docs/assets/image-20220529122243641.DvZEaKMY.png",t="/docs/assets/image-20220529105642643.BJr2nc8r.png",i="/docs/assets/image-20220529105839625.CyQK-H9l.png",c="/docs/assets/image-20220529110819547.DX5ODTYx.png",d="/docs/assets/image-20220529110913822.DAvQHZvy.png",u="/docs/assets/image-20220529121835739.BABnHvP0.png",g="/docs/assets/image-20220529121921680.DewOEKXN.png",h="/docs/assets/image-20220529125034909.B1WbTeMB.png",m="/docs/assets/image-20220529125338105.Buju0CM-.png",b="/docs/assets/image-20220529130019328.C-zDVKa2.png",k="/docs/assets/image-20220529130133968.qh3-ViRv.png",v="/docs/assets/image-20220529132518918.D8zuJUXt.png",_="/docs/assets/2022_05_29_13_33_23_761.g5NNgYE7.gif",q="/docs/assets/image-20220529140156963.DQJzNXD0.png",f="/docs/assets/image-20220529140648329.CiBXUa_6.png",y="/docs/assets/image-20220529141157474.sdZZ3npA.png",C="/docs/assets/image-20220529142742387.1LtT9mbC.png",B="/docs/assets/image-20220529150518521.B_ErKpgs.png",E="/docs/assets/image-20220529150735693.BELRBEP1.png",x="/docs/assets/image-20220529150913547.D7hVNetb.png",P="/docs/assets/image-20220529151102224.CvYdqFPE.png",R="/docs/assets/ribbon.UWcmB_lq.gif",S="/docs/assets/image-20220529163833049.r5ut7SYm.png",A="/docs/assets/image-20220529164229827.75_Yd9T_.png",I="/docs/assets/image-20220529165042105.BgfA0jQu.png",N="/docs/assets/image-20220529193801231.DKfRfcvt.png",D="/docs/assets/image-20220529194052045.DZGrK3VU.png",T="/docs/assets/image-20220529194235024.o1t5NtD4.png",Z="/docs/assets/image-20220529194356869.BfzWBA1F.png",j="/docs/assets/image-20220529194515563.81B2jcN5.png",F="/docs/assets/image-20220529194632015.Djox_upS.png",O="/docs/assets/image-20220529224051553.Dm7CIk4_.png",L="/docs/assets/image-20220529225242701.DKZnIVZF.png",H="/docs/assets/image-20220529225737970.z-aXzy9S.png",w="/docs/assets/image-20220529230319431.Ch9UvZvF.png",U="/docs/assets/image-20220529230610449.CEYp_mQF.png",M="/docs/assets/image-20220529232231550.BqvD44un.png",z="/docs/assets/image-20220529232257438.XgcQHHBA.png",K="/docs/assets/image-20220529232943387.BuBgUWWW.png",Q="/docs/assets/image-20220529234834765.CwwCRXvZ.png",V="/docs/assets/image-20220529234916863.D8t21-2e.png",W="/docs/assets/image-20220530000328618.bnMqEUpL.png",J="/docs/assets/image-20220530000535083.Dh0eK0eI.png",X="/docs/assets/image-20220530000731922.DT_O3c-N.png",G="/docs/assets/image-20220530000918363.ALkBs78G.png",Y="/docs/assets/image-20220530001017418.Dli9CBQT.png",$="/docs/assets/image-20220530001724364.BOmT-zjo.png",ss="/docs/assets/image-20220530001756661.Bw2ildTw.png",as="/docs/assets/image-20220530002130273.Rj7cGjLz.png",es="/docs/assets/2022_05_30_09_03_27_771.BUgJct3K.gif",hs=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"home/SpringCloud入门篇.md","filePath":"home/SpringCloud入门篇.md"}'),ns={name:"home/SpringCloud入门篇.md"},ps=n('<h2 id="一、认识微服务" tabindex="-1">一、认识微服务 <a class="header-anchor" href="#一、认识微服务" aria-label="Permalink to &quot;一、认识微服务&quot;">​</a></h2><blockquote><p>随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？</p></blockquote><h2 id="_1-单体架构" tabindex="-1">1.单体架构 <a class="header-anchor" href="#_1-单体架构" aria-label="Permalink to &quot;1.单体架构&quot;">​</a></h2><blockquote><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p></blockquote><p><img src="'+p+'" alt="image-20220529103635636"></p><p><strong>优点：</strong></p><ul><li>架构简单</li><li>部署成本低</li></ul><p><strong>缺点：</strong></p><ul><li>耦合度高（维护困难、升级困难）</li></ul><h2 id="_2-分布式架构" tabindex="-1">2.分布式架构 <a class="header-anchor" href="#_2-分布式架构" aria-label="Permalink to &quot;2.分布式架构&quot;">​</a></h2><blockquote><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p></blockquote><p><img src="'+l+'" alt="image-20220529104958819"></p><p><strong>优点：</strong></p><ul><li>降低服务耦合</li><li>有利于服务升级和拓展</li></ul><p><strong>缺点：</strong></p><ul><li>服务调用关系错综复杂</li></ul><blockquote><p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p></blockquote><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p>人们需要制定一套行之有效的标准来约束分布式架构。</p><h2 id="_3-微服务" tabindex="-1">3.微服务 <a class="header-anchor" href="#_3-微服务" aria-label="Permalink to &quot;3.微服务&quot;">​</a></h2><p>微服务的架构特征：</p><ul><li><strong>单一职责</strong>：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li><li><strong>自治</strong>：团队独立、技术独立、数据独立，独立部署和交付</li><li><strong>面向服务</strong>：服务提供统一标准的接口，与语言和技术无关</li><li><strong>隔离性强</strong>：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><p><img src="'+o+'" alt="image-20220529105324554"></p><p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到<strong>高内聚，低耦合</strong>。</p><p>因此，可以认为<strong>微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p><p>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</p><p>其中在Java领域最引人注目的就是<code>SpringCloud</code>提供的方案了。</p><h2 id="_4-微服务技术栈对比" tabindex="-1">4.微服务技术栈对比 <a class="header-anchor" href="#_4-微服务技术栈对比" aria-label="Permalink to &quot;4.微服务技术栈对比&quot;">​</a></h2><p><img src="'+r+'" alt="image-20220529122243641"></p><blockquote><p>SpringCloud是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82" target="_blank" rel="noreferrer">https://spring.io/projects/spring-cloud。</a></p></blockquote><p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p><strong>其中常见的组件包括</strong>：</p><p><img src="'+t+'" alt="image-20220529105642643"></p><h2 id="_6-版本对应关系" tabindex="-1">6.版本对应关系 <a class="header-anchor" href="#_6-版本对应关系" aria-label="Permalink to &quot;6.版本对应关系&quot;">​</a></h2><blockquote><p><strong>SpringCloud</strong>底层是依赖于<strong>SpringBoot</strong>的，并且有版本的兼容关系。</p></blockquote><p><img src="'+i+'" alt="image-20220529105839625"></p><p><strong>我们课堂学习的版本是 <code>Hoxton.SR10</code>，因此对应的SpringBoot版本是<code>2.3.x</code>版本。</strong></p><h2 id="_7-总结" tabindex="-1">7.总结 <a class="header-anchor" href="#_7-总结" aria-label="Permalink to &quot;7.总结&quot;">​</a></h2><ul><li><p>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</p></li><li><p>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</p></li><li><p>微服务：一种良好的分布式架构方案</p><ul><li><p>优点：拆分粒度更小、服务更独立、耦合度更低</p></li><li><p>缺点：架构非常复杂，运维、监控、部署难度提高</p></li></ul></li><li><p>SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</p></li></ul><h2 id="二、服务拆分和远程调用" tabindex="-1">二、服务拆分和远程调用 <a class="header-anchor" href="#二、服务拆分和远程调用" aria-label="Permalink to &quot;二、服务拆分和远程调用&quot;">​</a></h2><blockquote><p>任何分布式架构都离不开服务的拆分，微服务也是一样。</p></blockquote><h2 id="_1-服务拆分原则" tabindex="-1">1.服务拆分原则 <a class="header-anchor" href="#_1-服务拆分原则" aria-label="Permalink to &quot;1.服务拆分原则&quot;">​</a></h2><p>微服务拆分时要遵循以下几个原则：</p><ul><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li></ul><p><img src="'+c+'" alt="image-20220529110819547"></p><h2 id="_2-服务拆分示例" tabindex="-1">2.服务拆分示例 <a class="header-anchor" href="#_2-服务拆分示例" aria-label="Permalink to &quot;2.服务拆分示例&quot;">​</a></h2><blockquote><p>Demo下载：<a href="https://pan.baidu.com/s/1SonaiGjDo1Sx1p_1CP33Bg?pwd=1234" target="_blank" rel="noreferrer">https://pan.baidu.com/s/1SonaiGjDo1Sx1p_1CP33Bg?pwd=1234</a></p></blockquote><p>以课前资料中的微服务cloud-demo为例，其结构如下：</p><p><img src="'+d+'" alt="image-20220529110913822"></p><table><thead><tr><th>项目名称</th><th>项目描述</th></tr></thead><tbody><tr><td>order-service</td><td>订单微服务，负责订单相关业务</td></tr><tr><td>user-service</td><td>用户微服务，负责用户相关业务</td></tr></tbody></table><p>要求：</p><ul><li>订单微服务和用户微服务都必须有<strong>各自的数据库</strong>，相互独立</li><li>订单服务和用户服务都<strong>对外暴露Restful的接口</strong></li><li>订单服务如果需要查询用户信息，<strong>只能调用用户服务的Restful接口</strong>，不能查询用户数据库</li></ul><h2 id="_3-服务功能测试" tabindex="-1">3.服务功能测试 <a class="header-anchor" href="#_3-服务功能测试" aria-label="Permalink to &quot;3.服务功能测试&quot;">​</a></h2><ul><li><p>order-service</p><ul><li><p>提供功能：根据订单id查询订单详情</p></li><li><p>接口API：<a href="http://localhost:8080/order/%7BorderId%7D" target="_blank" rel="noreferrer">http://localhost:8080/order/{orderId}</a></p></li><li><p>访问测试：</p><p><img src="'+u+'" alt="image-20220529121835739"></p></li></ul></li><li><p>user-service</p><ul><li><p>提供功能：根据用户id查询用户信息</p></li><li><p>接口API：<a href="http://localhost:8081/user/%7BuserId%7D" target="_blank" rel="noreferrer">http://localhost:8081/user/{userId}</a></p></li><li><p>访问测试：</p><p><img src="'+g+'" alt="image-20220529121921680"></p></li></ul></li></ul><h2 id="_4-实现远程调用" tabindex="-1">4.实现远程调用 <a class="header-anchor" href="#_4-实现远程调用" aria-label="Permalink to &quot;4.实现远程调用&quot;">​</a></h2><blockquote><p>订单服务如果需要查询用户信息，<strong>只能调用用户服务的 Restful 接口</strong>，不能查询用户数据库.</p></blockquote><h3 id="_4-1-需求分析" tabindex="-1">4.1 需求分析 <a class="header-anchor" href="#_4-1-需求分析" aria-label="Permalink to &quot;4.1 需求分析&quot;">​</a></h3><hr><blockquote><p>根据订单id查询订单的同时，把订单所属的用户信息一起返回</p></blockquote><p><img src="'+h+'" alt="image-20220529125034909"></p><blockquote><p>远程调用的方式分析</p></blockquote><p><img src="'+m+`" alt="image-20220529125338105"></p><p>因此，我们需要在order-service中 向user-service发起一个http的请求，调用<a href="http://localhost:8081/user/%7BuserId%7D%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E3%80%82" target="_blank" rel="noreferrer">http://localhost:8081/user/{userId}这个接口。</a></p><p>大概的步骤是这样的：</p><ul><li>注册一个<code>RestTemplate</code>的实例到Spring容器</li><li>修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User</li><li>将查询的User填充到Order对象，一起返回</li></ul><h3 id="_4-2-注册resttemplate" tabindex="-1">4.2 注册RestTemplate <a class="header-anchor" href="#_4-2-注册resttemplate" aria-label="Permalink to &quot;4.2 注册RestTemplate&quot;">​</a></h3><hr><blockquote><p>首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例。</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>@Bean</span></span>
<span class="line"><span>public RestTemplate restTemplate(){</span></span>
<span class="line"><span>    return new RestTemplate();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>java</span></span></code></pre></div><h3 id="_4-3-实现远程调用" tabindex="-1">4.3 实现远程调用 <a class="header-anchor" href="#_4-3-实现远程调用" aria-label="Permalink to &quot;4.3 实现远程调用&quot;">​</a></h3><hr><blockquote><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>@Resource</span></span>
<span class="line"><span>private RestTemplate restTemplate;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public Order queryOrderById(Long orderId) {</span></span>
<span class="line"><span>    // 1.查询订单</span></span>
<span class="line"><span>    Order order = orderMapper.findById(orderId);</span></span>
<span class="line"><span>    // 2.使用restTemplate实现远程调用</span></span>
<span class="line"><span>    // 2.1指定请求url</span></span>
<span class="line"><span>    String url = &quot;http://localhost:8081/user/&quot; + order.getUserId();</span></span>
<span class="line"><span>    // 2.2发送http请求获取数据</span></span>
<span class="line"><span>    User user = restTemplate.getForObject(url, User.class);</span></span>
<span class="line"><span>    // 3.将获取到的用户信息封装进order对象</span></span>
<span class="line"><span>    order.setUser(user);</span></span>
<span class="line"><span>    // 4.返回</span></span>
<span class="line"><span>    return order;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>java</span></span></code></pre></div><p><img src="`+b+'" alt="image-20220529130019328"></p><p>在上面代码的 url 中，我们可以发现调用服务的地址采用硬编码，这在后续的开发中肯定是不理想的，这就需要<strong>服务注册中心</strong>（Eureka）来帮我们解决这个事情。</p><h2 id="_5-提供者与消费者" tabindex="-1">5.提供者与消费者 <a class="header-anchor" href="#_5-提供者与消费者" aria-label="Permalink to &quot;5.提供者与消费者&quot;">​</a></h2><blockquote><p>在服务调用关系中，会有两个不同的角色。</p></blockquote><p><strong>服务提供者</strong>：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</p><p><strong>服务消费者</strong>：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p><p><img src="'+k+'" alt="image-20220529130133968"></p><p>但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。</p><p>如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？</p><ul><li>对于A调用B的业务而言：A是服务消费者，B是服务提供者</li><li>对于B调用C的业务而言：B是服务消费者，C是服务提供者</li></ul><p>因此，服务B既可以是服务提供者，也可以是服务消费者。</p><h2 id="三、eureka注册中心" tabindex="-1">三、Eureka注册中心 <a class="header-anchor" href="#三、eureka注册中心" aria-label="Permalink to &quot;三、Eureka注册中心&quot;">​</a></h2><blockquote><p>当一个项目中同时有多个微服务，如果出现微服务的地址变更，删除，那么原本消费者那端写死的服务地址就会失效，如果消费者想找一个服务，也是很难找 ，那么这时候就可以将服务注册到Eureka，并可以监控服务，消费者也是到Eureka找对应的服务，相当于多了一个中间人。</p></blockquote><h2 id="_1-思考问题" tabindex="-1">1.思考问题 <a class="header-anchor" href="#_1-思考问题" aria-label="Permalink to &quot;1.思考问题&quot;">​</a></h2><blockquote><p>相对于上篇的远程调用为例，假如我们的服务提供者user-service部署了多个实例，如图：</p></blockquote><p><img src="'+v+'" alt="image-20220529132518918"></p><p>那么大家就需要思考以下几个问题：</p><ul><li><code>order-service</code>在发起远程调用的时候，该如何得知<code>user-service</code>实例的ip地址和端口？</li><li>有多个<code>user-service</code>实例地址，<code>order-service</code>调用时该如何选择？</li><li><code>order-service</code>如何得知某个<code>user-service</code>实例是否依然健康，是不是已经宕机？</li></ul><h2 id="_2-eureka的结构和作用" tabindex="-1">2.Eureka的结构和作用 <a class="header-anchor" href="#_2-eureka的结构和作用" aria-label="Permalink to &quot;2.Eureka的结构和作用&quot;">​</a></h2><blockquote><p>对于上面的问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：</p></blockquote><p><img src="'+_+'" alt=""></p><blockquote><p>通过以上GIF动画了解到Eureka的运行流程之后我们再来回答上面提到的几个问题</p></blockquote><ul><li><p><strong>问题1：<code>order-service</code>如何得知<code>user-service</code>实例地址？</strong></p><ul><li><code>user-service</code>服务实例启动后，将自己的信息注册到<code>eureka-server</code>（Eureka服务端）。这个叫<strong>服务注册</strong></li><li><code>eureka-server</code>保存服务名称到服务实例地址列表的映射关系</li><li><code>order-service</code>根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li></ul></li><li><p><strong>问题2：<code>order-service</code>如何从多个<code>user-service</code>实例中选择具体的实例？</strong></p><ul><li><code>order-service</code>从实例列表中利用负载均衡算法选中一个实例地址</li><li>向该实例地址发起远程调用</li></ul></li><li><p><strong>问题3：<code>order-service</code>如何得知某个<code>user-service</code>实例是否依然健康，是不是已经宕机？</strong></p><ul><li><code>user-service</code>会每隔一段时间（默认30秒）向<code>eureka-server</code>发起请求，报告自己状态，称为心跳</li><li>当超过一定时间没有发送心跳时，<code>eureka-server</code>会认为微服务实例故障，将该实例从服务列表中剔除</li><li><code>order-service</code>拉取服务时，就能将故障实例排除了</li></ul></li></ul><p><strong>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端</strong></p><blockquote><p>因此，接下来我们动手实践的步骤包括：</p></blockquote><p><img src="'+q+'" alt="image-20220529140156963"></p><h2 id="_3-搭建注册中心" tabindex="-1">3.搭建注册中心 <a class="header-anchor" href="#_3-搭建注册中心" aria-label="Permalink to &quot;3.搭建注册中心&quot;">​</a></h2><blockquote><p>基本流程：</p><ol><li>引入eureka-server依赖</li><li>添加@EnableEurekaServer注解</li><li>在application.yml中配置eureka地址</li></ol></blockquote><h3 id="_3-1-搭建-eureka-server-服务端" tabindex="-1">3.1 搭建 eureka-server 服务端 <a class="header-anchor" href="#_3-1-搭建-eureka-server-服务端" aria-label="Permalink to &quot;3.1 搭建 eureka-server 服务端&quot;">​</a></h3><hr><ul><li><p><strong>在<code>cloud-demo</code>父工程下，创建一个子模块</strong></p><p><img src="'+f+'" alt="image-20220529140648329"></p></li><li><p><strong>创建一个Maven工程填写服务信息</strong></p><p><img src="'+y+`" alt="image-20220529141157474"></p></li></ul><h3 id="_3-2-引入eureka服务端依赖" tabindex="-1">3.2 引入Eureka服务端依赖 <a class="header-anchor" href="#_3-2-引入eureka服务端依赖" aria-label="Permalink to &quot;3.2 引入Eureka服务端依赖&quot;">​</a></h3><hr><ul><li><p><strong>引入<code>eureka</code>依赖（这里引入的是Eureka服务端的依赖）</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span>
<span class="line"><span>xml</span></span></code></pre></div></li></ul><h3 id="_3-3-编写启动类" tabindex="-1">3.3 编写启动类 <a class="header-anchor" href="#_3-3-编写启动类" aria-label="Permalink to &quot;3.3 编写启动类&quot;">​</a></h3><hr><ul><li><p><strong>编写启动类并加上<code>@EnableEurekaServer</code>注解</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>package cn.itcast.eureka;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import org.springframework.boot.SpringApplication;</span></span>
<span class="line"><span>import org.springframework.boot.autoconfigure.SpringBootApplication;</span></span>
<span class="line"><span>import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span> * @Author Vz_Cat</span></span>
<span class="line"><span> * Created with IntelliJ IDEA.</span></span>
<span class="line"><span> * Created on 2022-05-29 14:17</span></span>
<span class="line"><span> * Description：Eureka注册中心启动类</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>@SpringBootApplication</span></span>
<span class="line"><span>@EnableEurekaServer //开启 eureka 的注册中心功能</span></span>
<span class="line"><span>public class EurekaApplication {</span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>        SpringApplication.run(EurekaApplication.class,args);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>java</span></span></code></pre></div></li></ul><h3 id="_3-4-编写配置文件" tabindex="-1">3.4 编写配置文件 <a class="header-anchor" href="#_3-4-编写配置文件" aria-label="Permalink to &quot;3.4 编写配置文件&quot;">​</a></h3><hr><ul><li><p><strong>编写配置文件<code>application.yml</code></strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>server:</span></span>
<span class="line"><span>  port: 10086</span></span>
<span class="line"><span>spring:</span></span>
<span class="line"><span>  application:</span></span>
<span class="line"><span>    name: eurekaserver</span></span>
<span class="line"><span>eureka:</span></span>
<span class="line"><span>  client:</span></span>
<span class="line"><span>    service-url:</span></span>
<span class="line"><span>      defaultZone: http://127.0.0.1:10086/eureka</span></span>
<span class="line"><span>yml</span></span></code></pre></div><p>其中 <code>default-zone</code> 是因为前面配置类开启了注册中心所需要配置的 eureka 的<strong>地址信息</strong>，因为 eureka 本身也是一个微服务，这里也要将自己注册进来，当后面 eureka <strong>集群</strong>时，这里就可以填写多个，使用 “,” 隔开。</p></li></ul><h3 id="_3-5-启动服务" tabindex="-1">3.5 启动服务 <a class="header-anchor" href="#_3-5-启动服务" aria-label="Permalink to &quot;3.5 启动服务&quot;">​</a></h3><hr><ul><li><p><strong>启动服务进行测试</strong></p><p>启动完成后访问：<a href="http://localhost:10086/%EF%BC%8C%E5%87%BA%E7%8E%B0%E4%BB%A5%E4%B8%8B%E7%95%8C%E9%9D%A2%E5%B0%B1%E4%BB%A3%E8%A1%A8%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F%E4%BA%86%EF%BC%81" target="_blank" rel="noreferrer">http://localhost:10086/，出现以下界面就代表搭建成功了！</a></p><p><img src="`+C+`" alt="image-20220529142742387"></p></li></ul><h2 id="_4-服务注册" tabindex="-1">4.服务注册 <a class="header-anchor" href="#_4-服务注册" aria-label="Permalink to &quot;4.服务注册&quot;">​</a></h2><blockquote><p>基本流程：</p><ol><li>引入eureka-client依赖</li><li>在application.yml中配置eureka地址</li></ol></blockquote><h3 id="_4-1-引入依赖" tabindex="-1">4.1 引入依赖 <a class="header-anchor" href="#_4-1-引入依赖" aria-label="Permalink to &quot;4.1 引入依赖&quot;">​</a></h3><hr><ul><li><p><strong>在<code>user-service</code>的pom文件中，引入下面的<code>eureka-client</code>依赖（这里引入的是Eureka客户端的依赖）</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span>
<span class="line"><span>xml</span></span></code></pre></div></li></ul><h3 id="_4-2-修改配置文件" tabindex="-1">4.2 修改配置文件 <a class="header-anchor" href="#_4-2-修改配置文件" aria-label="Permalink to &quot;4.2 修改配置文件&quot;">​</a></h3><hr><ul><li><p><strong>在<code>user-service</code>中，修改<code>application.yml</code>文件，添加服务名称、<code>eureka</code>地址</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>server:</span></span>
<span class="line"><span>  port: 8081</span></span>
<span class="line"><span>spring:</span></span>
<span class="line"><span>  application:</span></span>
<span class="line"><span>    name: userservice</span></span>
<span class="line"><span>  datasource:</span></span>
<span class="line"><span>    url: jdbc:mysql://localhost:3306/cloud_user?useSSL=false</span></span>
<span class="line"><span>    username: root</span></span>
<span class="line"><span>    password: 132537</span></span>
<span class="line"><span>    driver-class-name: com.mysql.jdbc.Driver</span></span>
<span class="line"><span>mybatis:</span></span>
<span class="line"><span>  type-aliases-package: cn.itcast.user.pojo</span></span>
<span class="line"><span>  configuration:</span></span>
<span class="line"><span>    map-underscore-to-camel-case: true</span></span>
<span class="line"><span>logging:</span></span>
<span class="line"><span>  level:</span></span>
<span class="line"><span>    cn.itcast: debug</span></span>
<span class="line"><span>  pattern:</span></span>
<span class="line"><span>    dateformat: MM-dd HH:mm:ss:SSS</span></span>
<span class="line"><span>eureka:</span></span>
<span class="line"><span>  client:</span></span>
<span class="line"><span>    service-url:</span></span>
<span class="line"><span>      defaultZone: http://127.0.0.1:10086/eureka</span></span>
<span class="line"><span>yml</span></span></code></pre></div></li></ul><h3 id="_4-3-启动多个user-service实例" tabindex="-1">4.3 启动多个user-service实例 <a class="header-anchor" href="#_4-3-启动多个user-service实例" aria-label="Permalink to &quot;4.3 启动多个user-service实例&quot;">​</a></h3><hr><blockquote><p>为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。</p></blockquote><ul><li><p><strong>首先，复制原来的<code>user-service</code>启动配置</strong></p><p><img src="`+B+'" alt="image-20220529150518521"></p></li><li><p><strong>然后，在弹出的窗口中，填写信息</strong></p><p><img src="'+E+'" alt="image-20220529150735693"></p></li><li><p><strong>启动新建的<code>user-service</code>示例</strong></p><p><img src="'+x+'" alt="image-20220529150913547"></p></li><li><p><strong>查看<code>eureka-server</code>管理页面</strong></p><p><img src="'+P+`" alt="image-20220529151102224"></p></li></ul><h2 id="_5-服务发现" tabindex="-1">5.服务发现 <a class="header-anchor" href="#_5-服务发现" aria-label="Permalink to &quot;5.服务发现&quot;">​</a></h2><blockquote><p>基本流程：</p><ul><li>引入<code>eureka-client</code>依赖</li><li>在<code>application.yml</code>中配置eureka地址</li><li>给<code>RestTemplate</code>添加<code>@LoadBalanced</code>注解</li><li>用服务提供者的服务名称远程调用</li></ul></blockquote><h3 id="_5-1-引入依赖" tabindex="-1">5.1 引入依赖 <a class="header-anchor" href="#_5-1-引入依赖" aria-label="Permalink to &quot;5.1 引入依赖&quot;">​</a></h3><hr><blockquote><p>之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。</p></blockquote><ul><li><p><strong>在<code>order-service</code>的pom文件中，引入下面的<code>eureka-client</code>依赖</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span>
<span class="line"><span>xml</span></span></code></pre></div></li></ul><h3 id="_5-2-修改配置文件" tabindex="-1">5.2 修改配置文件 <a class="header-anchor" href="#_5-2-修改配置文件" aria-label="Permalink to &quot;5.2 修改配置文件&quot;">​</a></h3><hr><blockquote><p>服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息</p></blockquote><ul><li><p><strong>在order-service中，修改application.yml文件，添加服务名称、eureka地址</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>server:</span></span>
<span class="line"><span>  port: 8080</span></span>
<span class="line"><span>spring:</span></span>
<span class="line"><span>  application:</span></span>
<span class="line"><span>    name: orderservice</span></span>
<span class="line"><span>  datasource:</span></span>
<span class="line"><span>    url: jdbc:mysql://localhost:3306/cloud_order?useSSL=false</span></span>
<span class="line"><span>    username: root</span></span>
<span class="line"><span>    password: 132537</span></span>
<span class="line"><span>    driver-class-name: com.mysql.jdbc.Driver</span></span>
<span class="line"><span>mybatis:</span></span>
<span class="line"><span>  type-aliases-package: cn.itcast.user.pojo</span></span>
<span class="line"><span>  configuration:</span></span>
<span class="line"><span>    map-underscore-to-camel-case: true</span></span>
<span class="line"><span>logging:</span></span>
<span class="line"><span>  level:</span></span>
<span class="line"><span>    cn.itcast: debug</span></span>
<span class="line"><span>  pattern:</span></span>
<span class="line"><span>    dateformat: MM-dd HH:mm:ss:SSS</span></span>
<span class="line"><span>eureka:</span></span>
<span class="line"><span>  client:</span></span>
<span class="line"><span>    service-url:</span></span>
<span class="line"><span>      defaultZone: http://127.0.0.1:10086/eureka</span></span>
<span class="line"><span>yml</span></span></code></pre></div></li></ul><h3 id="_5-3-服务拉取和负载均衡" tabindex="-1">5.3 服务拉取和负载均衡 <a class="header-anchor" href="#_5-3-服务拉取和负载均衡" aria-label="Permalink to &quot;5.3 服务拉取和负载均衡&quot;">​</a></h3><hr><blockquote><p>最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。</p><p>不过这些动作不用我们去做，只需要添加一些注解即可。</p></blockquote><ul><li><p><strong>在<code>order-service</code>的<code>OrderApplication</code>中，给<code>RestTemplate</code>这个Bean添加一个<code>@LoadBalanced</code>注解：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>@Bean</span></span>
<span class="line"><span>@LoadBalanced</span></span>
<span class="line"><span>public RestTemplate restTemplate(){</span></span>
<span class="line"><span>    return new RestTemplate();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>java</span></span></code></pre></div></li><li><p><strong>修改<code>order-service</code>服务中的<code>OrderService</code>类中的<code>queryOrderById</code>方法。修改访问的url路径，用服务名代替ip、端口：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>public Order queryOrderById(Long orderId) {</span></span>
<span class="line"><span>    // 1.查询订单</span></span>
<span class="line"><span>    Order order = orderMapper.findById(orderId);</span></span>
<span class="line"><span>    // 2.使用restTemplate实现远程调用</span></span>
<span class="line"><span>    // 2.1指定请求url</span></span>
<span class="line"><span>    String url = &quot;http://userservice/user/&quot; + order.getUserId();</span></span>
<span class="line"><span>    // 2.2发送http请求获取数据</span></span>
<span class="line"><span>    User user = restTemplate.getForObject(url, User.class);</span></span>
<span class="line"><span>    // 3.将获取到的用户信息封装进order对象</span></span>
<span class="line"><span>    order.setUser(user);</span></span>
<span class="line"><span>    // 4.返回</span></span>
<span class="line"><span>    return order;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>java</span></span></code></pre></div></li></ul><p><strong>Spring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡</strong></p><h2 id="四、ribbon负载均衡" tabindex="-1">四、Ribbon负载均衡 <a class="header-anchor" href="#四、ribbon负载均衡" aria-label="Permalink to &quot;四、Ribbon负载均衡&quot;">​</a></h2><blockquote><p>上一节中，我们添加了<code>@LoadBalanced</code>注解，即可实现负载均衡功能，这是什么原理呢？</p></blockquote><h2 id="_1-负载均衡原理" tabindex="-1">1.负载均衡原理 <a class="header-anchor" href="#_1-负载均衡原理" aria-label="Permalink to &quot;1.负载均衡原理&quot;">​</a></h2><blockquote><p><code>SpringCloud</code>底层其实是利用了一个名为<code>Ribbon</code>的组件，来实现负载均衡功能的。</p></blockquote><p><img src="`+R+'" alt="ribbon"></p><p>那么我们发出的请求明明是<a href="http://userservice/user/1%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8F%98%E6%88%90%E4%BA%86http://localhost:8081%E7%9A%84%E5%91%A2%EF%BC%9F" target="_blank" rel="noreferrer">http://userservice/user/1，怎么变成了http://localhost:8081的呢？</a></p><h2 id="_2-详细执行流程" tabindex="-1">2.详细执行流程 <a class="header-anchor" href="#_2-详细执行流程" aria-label="Permalink to &quot;2.详细执行流程&quot;">​</a></h2><blockquote><p>SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下</p></blockquote><p><img src="'+S+'" alt="image-20220529163833049"></p><p><strong>基本流程如下：</strong></p><ul><li>拦截我们的<code>RestTemplate</code>请求<a href="http://userservice/user/1" target="_blank" rel="noreferrer">http://userservice/user/1</a></li><li><code>RibbonLoadBalancerClient</code>会从请求url中获取服务名称，也就是<code>user-service</code></li><li><code>DynamicServerListLoadBalancer</code>根据<code>user-service</code>到<code>eureka</code>拉取服务列表</li><li><code>eureka</code>返回列表，<code>localhost:8081</code>、<code>localhost:8082</code></li><li><code>IRule</code>利用内置负载均衡规则，从列表中选择一个，例如<code>localhost:8081</code></li><li><code>RibbonLoadBalancerClient</code>修改请求地址，用<code>localhost:8081</code>替代<code>userservice</code>，得到<a href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82" target="_blank" rel="noreferrer">http://localhost:8081/user/1，发起真实请求</a></li></ul><h2 id="_3-负载均衡策略" tabindex="-1">3.负载均衡策略 <a class="header-anchor" href="#_3-负载均衡策略" aria-label="Permalink to &quot;3.负载均衡策略&quot;">​</a></h2><h3 id="_3-1-负载均衡关系图" tabindex="-1">3.1 负载均衡关系图 <a class="header-anchor" href="#_3-1-负载均衡关系图" aria-label="Permalink to &quot;3.1 负载均衡关系图&quot;">​</a></h3><hr><blockquote><p>负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类</p></blockquote><p><img src="'+A+`" alt="image-20220529164229827"></p><p><strong>不同规则的含义如下：</strong></p><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略：</td></tr><tr><td>（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。</td><td></td></tr><tr><td>（2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的..ActiveConnectionsLimit属性进行配置。</td><td></td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong></td><td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><p><strong>默认的实现就是ZoneAvoidanceRule，是一种轮询方案</strong></p><h3 id="_3-2-自定义负载均衡策略" tabindex="-1">3.2 自定义负载均衡策略 <a class="header-anchor" href="#_3-2-自定义负载均衡策略" aria-label="Permalink to &quot;3.2 自定义负载均衡策略&quot;">​</a></h3><hr><blockquote><p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p></blockquote><ol><li><p><strong>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule（全局生效）</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>@Bean</span></span>
<span class="line"><span>public IRule randomRule(){</span></span>
<span class="line"><span>    return new RandomRule();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>java</span></span></code></pre></div></li><li><p><strong>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则（指定生效）</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务</span></span>
<span class="line"><span>  ribbon:</span></span>
<span class="line"><span>    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 </span></span>
<span class="line"><span>yml</span></span></code></pre></div></li></ol><p><strong><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</strong></p><h2 id="_4-饥饿加载" tabindex="-1">4.饥饿加载 <a class="header-anchor" href="#_4-饥饿加载" aria-label="Permalink to &quot;4.饥饿加载&quot;">​</a></h2><blockquote><p>当我们启动 orderservice，第一次访问时，时间消耗会大很多，这是因为 Ribbon <strong>懒加载</strong>的机制。</p></blockquote><p><img src="`+I+`" alt="image-20220529165042105"></p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>ribbon:</span></span>
<span class="line"><span>  eager-load:</span></span>
<span class="line"><span>    enabled: true</span></span>
<span class="line"><span>    clients: userservice # 项目启动时直接去拉取userservice的集群，多个用&quot;,&quot;隔开</span></span>
<span class="line"><span>yml</span></span></code></pre></div><h2 id="五、nacos注册中心" tabindex="-1">五、Nacos注册中心 <a class="header-anchor" href="#五、nacos注册中心" aria-label="Permalink to &quot;五、Nacos注册中心&quot;">​</a></h2><blockquote><p><a href="https://nacos.io/" target="_blank" rel="noreferrer">Nacos</a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noreferrer">SpringCloud</a>中的一个组件。相比<a href="https://github.com/Netflix/eureka" target="_blank" rel="noreferrer">Eureka</a>功能更加丰富，在国内受欢迎程度较高</p></blockquote><h2 id="_1-安装nacos" tabindex="-1">1.安装Nacos <a class="header-anchor" href="#_1-安装nacos" aria-label="Permalink to &quot;1.安装Nacos&quot;">​</a></h2><blockquote><p>本次安装是基于Windos下安装的，实际部署项目则需要安装到Linux系统下。</p></blockquote><ol><li><p><strong>下载Nacos安装包并解压（解压到非中文路径下）</strong>：<a href="https://pan.baidu.com/s/1b6QEkglaL8Q81F8-Hxvdwg?pwd=1234" target="_blank" rel="noreferrer">nacos-server-1.4.1.zip</a></p><p><img src="`+N+'" alt="image-20220529193801231"></p><p>目录说明：</p><ul><li><code>bin</code>：启动脚本</li><li><code>conf</code>：配置文件</li></ul></li><li><p><strong>Nacos的默认端口号是<code>8848</code>，若需修改的话修改<code>conf</code>文件夹下的<code>application.properties</code>文件即可</strong></p><p><img src="'+D+'" alt="image-20220529194052045"></p></li><li><p><strong>启动Nacos则是进入<code>bin</code>目录下打开<code>cmd</code>命令控制台执行以下命令</strong></p><p><img src="'+T+`" alt="image-20220529194235024"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>startup.cmd -m standalone</span></span>
<span class="line"><span>sh</span></span></code></pre></div></li><li><p><strong>执行后的效果如下图</strong></p><p><img src="`+Z+'" alt="image-20220529194356869"></p></li><li><p><strong>访问浏览器<a href="http://127.0.0.1:8848/nacos" target="_blank" rel="noreferrer">http://127.0.0.1:8848/nacos</a></strong></p><p><img src="'+j+'" alt="image-20220529194515563"></p></li><li><p><strong>默认的账号和密码都是<code>nacos</code></strong></p><p><img src="'+F+`" alt="image-20220529194632015"></p></li></ol><h2 id="_2-服务注册到nacos" tabindex="-1">2.服务注册到nacos <a class="header-anchor" href="#_2-服务注册到nacos" aria-label="Permalink to &quot;2.服务注册到nacos&quot;">​</a></h2><blockquote><p><strong>Nacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。</strong></p></blockquote><p><strong>主要差异在于</strong>：</p><ul><li>依赖不同</li><li>服务地址不同</li></ul><p><strong>因此我们如果需要将Eureka转换为Nacos注册中心仅需更换依赖，修改配置文件即可！</strong></p><p><strong>基本实现流程</strong>：</p><ul><li>引入nacos.discovery依赖</li><li>配置nacos地址spring.cloud.nacos.server-addr</li></ul><h3 id="_2-1-引入依赖" tabindex="-1">2.1 引入依赖 <a class="header-anchor" href="#_2-1-引入依赖" aria-label="Permalink to &quot;2.1 引入依赖&quot;">​</a></h3><hr><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的依赖。</p></blockquote><ul><li><p><strong>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入<code>SpringCloudAlibaba</code>的依赖：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span></span>
<span class="line"><span>    &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;</span></span>
<span class="line"><span>    &lt;type&gt;pom&lt;/type&gt;</span></span>
<span class="line"><span>    &lt;scope&gt;import&lt;/scope&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span>
<span class="line"><span>xml</span></span></code></pre></div></li><li><p><strong>然后在<code>user-service</code>和<code>order-service</code>中的pom文件中引入<code>nacos-discovery</code>依赖：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span>
<span class="line"><span>xml</span></span></code></pre></div></li></ul><h3 id="_2-2-修改配置文件" tabindex="-1">2.2 修改配置文件 <a class="header-anchor" href="#_2-2-修改配置文件" aria-label="Permalink to &quot;2.2 修改配置文件&quot;">​</a></h3><hr><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的地址</p></blockquote><ul><li><p><strong>在<code>user-service</code>和<code>order-service</code>的<code>application.yml</code>中添加nacos地址</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>spring:</span></span>
<span class="line"><span>  cloud:</span></span>
<span class="line"><span>    nacos:</span></span>
<span class="line"><span>      server-addr: localhost:8848</span></span>
<span class="line"><span>yml</span></span></code></pre></div></li></ul><h3 id="_2-3-重启服务" tabindex="-1">2.3 重启服务 <a class="header-anchor" href="#_2-3-重启服务" aria-label="Permalink to &quot;2.3 重启服务&quot;">​</a></h3><hr><blockquote><p>重启微服务后，登录nacos管理页面，可以看到微服务信息</p></blockquote><p><img src="`+O+'" alt="image-20220529224051553"></p><h2 id="_3-服务分级存储模型" tabindex="-1">3.服务分级存储模型 <a class="header-anchor" href="#_3-服务分级存储模型" aria-label="Permalink to &quot;3.服务分级存储模型&quot;">​</a></h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的<code>user-service</code>，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos就将同一机房内的实例，划分为一个<strong>集群</strong>。</p><p>也就是说，<code>user-service</code>是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p><p><img src="'+L+'" alt="image-20220529225242701"></p><blockquote><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</p></blockquote><p><img src="'+H+`" alt="image-20220529225737970"></p><p><strong>杭州机房内的<code>order-service</code>应该优先访问同机房的<code>user-service</code>。</strong></p><h3 id="_3-1-给user-service配置集群" tabindex="-1">3.1 给user-service配置集群 <a class="header-anchor" href="#_3-1-给user-service配置集群" aria-label="Permalink to &quot;3.1 给user-service配置集群&quot;">​</a></h3><hr><ul><li><p><strong>修改<code>user-service</code>的<code>application.yml</code>文件，添加集群配置</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>spring:</span></span>
<span class="line"><span>  cloud:</span></span>
<span class="line"><span>    nacos:</span></span>
<span class="line"><span>      server-addr: localhost:8848</span></span>
<span class="line"><span>      discovery:</span></span>
<span class="line"><span>        cluster-name: HZ # 集群名称</span></span>
<span class="line"><span>yml</span></span></code></pre></div></li><li><p><strong>重启两个 <code>user-service</code> 实例后，我们再去启动一个上海集群的实例</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH</span></span>
<span class="line"><span>sh</span></span></code></pre></div><p><img src="`+w+'" alt="image-20220529230319431"></p></li><li><p><strong>查看 <code>nacos</code> 控制台</strong></p><p><img src="'+U+`" alt="image-20220529230610449"></p></li></ul><h3 id="_3-2-同集群优先的负载均衡" tabindex="-1">3.2 同集群优先的负载均衡 <a class="header-anchor" href="#_3-2-同集群优先的负载均衡" aria-label="Permalink to &quot;3.2 同集群优先的负载均衡&quot;">​</a></h3><hr><blockquote><p>Ribbon的默认实现 <code>ZoneAvoidanceRule</code> 并不能实现根据同集群优先来实现负载均衡，我们把规则改成 <strong><code>NacosRule</code></strong> 即可。我们是用 <code>orderservice</code> 调用 <code>userservice</code>，所以在 <code>orderservice</code> 配置规则。</p></blockquote><ol><li><p><strong>给<code>order-service</code>配置集群信息</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>spring:</span></span>
<span class="line"><span>  cloud:</span></span>
<span class="line"><span>    nacos:</span></span>
<span class="line"><span>      server-addr: localhost:8848</span></span>
<span class="line"><span>      discovery:</span></span>
<span class="line"><span>        cluster-name: HZ # 集群名称</span></span>
<span class="line"><span>yml</span></span></code></pre></div></li><li><p><strong>修改负载均衡规则（两种方式都可以，这里我选择使用yml配置方式）</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>userservice:</span></span>
<span class="line"><span>  ribbon:</span></span>
<span class="line"><span>    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则 </span></span>
<span class="line"><span>yml</span></span></code></pre></div></li></ol><p><strong>NacosRule的规则是同集群之间随机调用，若同集群的实例全部挂掉，则调用别的集群的实例。</strong></p><h3 id="_3-3-启动服务测试" tabindex="-1">3.3 启动服务测试 <a class="header-anchor" href="#_3-3-启动服务测试" aria-label="Permalink to &quot;3.3 启动服务测试&quot;">​</a></h3><hr><blockquote><p><strong>现在我启动了四个服务，分别是：</strong></p></blockquote><ul><li>orderservice - HZ</li><li>userservice - HZ</li><li>userservice1 - HZ</li><li>userservice2 - SH</li></ul><blockquote><p><strong>然后我们分别访问：</strong></p></blockquote><ul><li><a href="http://localhost:8080/order/101" target="_blank" rel="noreferrer">http://localhost:8080/order/101</a></li><li><a href="http://localhost:8080/order/102" target="_blank" rel="noreferrer">http://localhost:8080/order/102</a></li><li><a href="http://localhost:8080/order/103" target="_blank" rel="noreferrer">http://localhost:8080/order/103</a></li><li><a href="http://localhost:8080/order/104" target="_blank" rel="noreferrer">http://localhost:8080/order/104</a></li><li><a href="http://localhost:8080/order/105" target="_blank" rel="noreferrer">http://localhost:8080/order/105</a></li></ul><blockquote><p><strong>在访问中我们发现，只有同在一个 HZ 集群下的 <code>userservice</code>、<code>userservice1</code> 会被调用，并且是==随机==的。</strong></p></blockquote><p><img src="`+M+'" alt="image-20220529232231550"></p><p><img src="'+z+'" alt="image-20220529232257438"></p><blockquote><p><strong>我们试着把 <code>userservice</code>、<code>userservice2</code> 停掉。依旧可以访问。</strong></p></blockquote><p><strong>在 userservice3 控制台可以看到发出了一串的警告，因为 orderservice 本身是在 HZ 集群的，这波 HZ 集群没有了 userservice，就会去别的集群找。</strong></p><p><img src="'+K+'" alt="image-20220529232943387"></p><h2 id="_4-权重配置" tabindex="-1">4.权重配置 <a class="header-anchor" href="#_4-权重配置" aria-label="Permalink to &quot;4.权重配置&quot;">​</a></h2><p><strong>实际部署中会出现这样的场景</strong>：</p><ul><li>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。但默认情况下 NacosRule 是同集群内随机挑选，不会考虑机器的性能问题。</li><li>因此，Nacos 提供了<strong>权重配置来控制访问频率</strong>，<code>0~1</code> 之间，权重越大则访问频率越高，权重修改为 0，则该实例永远不会被访问。</li></ul><p><strong>在 Nacos 控制台，找到 <code>user-service</code> 的实例列表，点击编辑，即可修改权重</strong>。</p><p><img src="'+Q+'" alt="image-20220529234834765"></p><p><strong>在弹出的编辑窗口，修改权重</strong></p><p><img src="'+V+'" alt="image-20220529234916863"></p><p><strong><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</strong></p><h2 id="_5-环境隔离" tabindex="-1">5.环境隔离 <a class="header-anchor" href="#_5-环境隔离" aria-label="Permalink to &quot;5.环境隔离&quot;">​</a></h2><p><strong>Nacos 提供了 <code>namespace</code> 来实现环境隔离功能。</strong></p><ul><li>Nacos 中可以有多个 namespace</li><li>namespace 下可以有 group、service 等</li><li>不同 namespace 之间<strong>相互隔离</strong>，例如不同 namespace 的服务互相不可见</li></ul><p><img src="'+W+'" alt="image-20220530000328618"></p><h3 id="_5-1-创建namespace" tabindex="-1">5.1 创建namespace <a class="header-anchor" href="#_5-1-创建namespace" aria-label="Permalink to &quot;5.1 创建namespace&quot;">​</a></h3><hr><ul><li><p><strong>默认情况下，所有service、data、group都在同一个namespace，名为<code>public</code></strong></p><p><img src="'+J+'" alt="image-20220530000535083"></p></li><li><p><strong>我们可以点击页面新增按钮，添加一个 <code>namespace</code></strong></p><p><img src="'+X+'" alt="image-20220530000731922"></p></li><li><p><strong>然后，填写表单</strong></p><p><img src="'+G+'" alt="image-20220530000918363"></p></li><li><p><strong>就能在页面看到一个新的<code>namespace</code></strong></p><p><img src="'+Y+`" alt="image-20220530001017418"></p></li></ul><h3 id="_5-2-配置namespace" tabindex="-1">5.2 配置namespace <a class="header-anchor" href="#_5-2-配置namespace" aria-label="Permalink to &quot;5.2 配置namespace&quot;">​</a></h3><hr><blockquote><p><strong>给微服务配置<code>namespace</code>只能通过修改配置来实现。</strong></p></blockquote><ul><li><p><strong>例如，修改 <code>order-service</code> 的 <code>application.yml</code> 文件</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>spring:</span></span>
<span class="line"><span>  cloud:</span></span>
<span class="line"><span>    nacos:</span></span>
<span class="line"><span>      server-addr: localhost:8848</span></span>
<span class="line"><span>      discovery:</span></span>
<span class="line"><span>        cluster-name: HZ</span></span>
<span class="line"><span>        namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间，填ID</span></span>
<span class="line"><span>yml</span></span></code></pre></div></li><li><p><strong>重启<code>order-service</code>后，访问控制台，可以看到下面的结果</strong></p><p><strong>public命名空间</strong></p><p><img src="`+$+'" alt="image-20220530001724364"></p><p><strong>dev命名空间</strong></p><p><img src="'+ss+'" alt="image-20220530001756661"></p></li><li><p><strong>此时访问<code>order-service</code>，因为<code>namespace</code>不同，会导致找不到<code>userservice</code>，控制台会报错</strong></p><p><img src="'+as+`" alt="image-20220530002130273"></p></li></ul><p><strong>总结：</strong></p><ul><li>每个namespace都有唯一id</li><li>服务设置namespace时要写id而不是名称</li><li>不同namespace下的服务互相不可见</li></ul><h2 id="_6-nacos与eureka的区别" tabindex="-1">6.Nacos与Eureka的区别 <a class="header-anchor" href="#_6-nacos与eureka的区别" aria-label="Permalink to &quot;6.Nacos与Eureka的区别&quot;">​</a></h2><h3 id="_6-1-临时实例和非临时实例" tabindex="-1">6.1 临时实例和非临时实例 <a class="header-anchor" href="#_6-1-临时实例和非临时实例" aria-label="Permalink to &quot;6.1 临时实例和非临时实例&quot;">​</a></h3><hr><p><strong>Nacos的服务实例分为两种类型：</strong></p><ul><li><p><strong>临时实例</strong>：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p></li><li><p><strong>非临时实例</strong>：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><p><strong>配置一个服务实例为永久实例</strong>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>spring:</span></span>
<span class="line"><span>  cloud:</span></span>
<span class="line"><span>    nacos:</span></span>
<span class="line"><span>      discovery:</span></span>
<span class="line"><span>        ephemeral: false # 设置为非临时实例</span></span>
<span class="line"><span>yml</span></span></code></pre></div><h3 id="_6-2-nacos的执行过程" tabindex="-1">6.2 Nacos的执行过程 <a class="header-anchor" href="#_6-2-nacos的执行过程" aria-label="Permalink to &quot;6.2 Nacos的执行过程&quot;">​</a></h3><hr><blockquote><p><strong>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异</strong></p></blockquote><p><img src="`+es+'" alt="录制_2022_05_30_09_03_27_771"></p><h3 id="_6-3-总结" tabindex="-1">6.3 总结 <a class="header-anchor" href="#_6-3-总结" aria-label="Permalink to &quot;6.3 总结&quot;">​</a></h3><hr><ul><li><p><strong><code>Nacos</code>与<code>eureka</code>的共同点</strong></p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li><p><strong><code>Nacos</code>与<code>Eureka</code>的区别</strong></p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul>',262),ls=[ps];function os(rs,ts,is,cs,ds,us){return e(),a("div",null,ls)}const ms=s(ns,[["render",os]]);export{hs as __pageData,ms as default};

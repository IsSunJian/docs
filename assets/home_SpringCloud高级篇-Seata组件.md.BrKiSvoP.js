import{_ as a,c as s,o as n,a4 as l}from"./chunks/framework.-JfgED0h.js";const p="/docs/assets/image-20230110235855000.DDdvoChm.png",e="/docs/assets/image-20230111000651902.BH-l-dyf.png",i="/docs/assets/image-20230111075810573.CMYPJOhX.png",t="/docs/assets/image-20230111080348548.Dl983gvt.png",o="/docs/assets/image-20230111081740759.C1FQQnFI.png",c="/docs/assets/image-20230111085348439.F2SDftGI.png",r="/docs/assets/image-20230111085714845.BYV4-Mk1.png",d="/docs/assets/image-20230111090300945.C3X8cXTx.png",u="/docs/assets/image-20230111092039993.C4v4quo_.png",g="/docs/assets/image-20230111092644754.CG2LLrgU.png",h="/docs/assets/image-20230111093618099.DnuzwOiT.png",v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"home/SpringCloud高级篇-Seata组件.md","filePath":"home/SpringCloud高级篇-Seata组件.md"}'),_={name:"home/SpringCloud高级篇-Seata组件.md"},m=l('<h2 id="一、事务问题" tabindex="-1">一、事务问题 <a class="header-anchor" href="#一、事务问题" aria-label="Permalink to &quot;一、事务问题&quot;">​</a></h2><h2 id="_1-本地事务" tabindex="-1">1.本地事务 <a class="header-anchor" href="#_1-本地事务" aria-label="Permalink to &quot;1.本地事务&quot;">​</a></h2><blockquote><p>本地事务：也就是传统的<strong>单机事务</strong>。在传统数据库事务中，必须要满足四个原则：<code>ACID</code></p></blockquote><p><img src="'+p+'" alt="image-20230110235855000"></p><h2 id="_2-分布式事务" tabindex="-1">2.分布式事务 <a class="header-anchor" href="#_2-分布式事务" aria-label="Permalink to &quot;2.分布式事务&quot;">​</a></h2><blockquote><p><strong>分布式事务</strong>：就是指不是在单个服务或单个数据库架构下，产生的事务</p></blockquote><ul><li>跨数据源的分布式事务</li><li>跨服务的分布式事务</li><li>综合情况</li></ul><h2 id="二、理论基础" tabindex="-1">二、理论基础 <a class="header-anchor" href="#二、理论基础" aria-label="Permalink to &quot;二、理论基础&quot;">​</a></h2><h2 id="_1-cap定理" tabindex="-1">1.CAP定理 <a class="header-anchor" href="#_1-cap定理" aria-label="Permalink to &quot;1.CAP定理&quot;">​</a></h2><blockquote><p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。</p></blockquote><ul><li><code>Consistency</code> (一致性) <ul><li>用户访问分布式系统中的任意节点，得到的数据必须一致。</li></ul></li><li><code>Availability</code> (可用性) <ul><li>用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。</li></ul></li><li><code>Partition Tolerance</code> (分区容错性) <ul><li>因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。在集群出现分区时，整个系统也要持续对外提供服务</li></ul></li><li><strong>CP和AP：</strong><ul><li><strong>分区容错是必须保证的，当发生网络分区的时候，如果要继续服务，那么强一致性和可用性只能 2 选 1</strong></li></ul></li></ul><p><img src="'+e+'" alt="image-20230111000651902"></p><h2 id="_2-base理论" tabindex="-1">2.BASE理论 <a class="header-anchor" href="#_2-base理论" aria-label="Permalink to &quot;2.BASE理论&quot;">​</a></h2><blockquote><p><code>BASE</code>理论是对<code>CAP</code>的一种解决思路，包含三个思想</p></blockquote><ul><li><strong>Basically Available</strong> <strong>（基本可用）</strong>：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li><li>**Soft State（软状态）：**在一定时间内，允许出现中间状态，比如临时的不一致状态。</li><li><strong>Eventually Consistent（最终一致性）</strong>：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</li></ul><h2 id="_3-解决分布式事务" tabindex="-1">3.解决分布式事务 <a class="header-anchor" href="#_3-解决分布式事务" aria-label="Permalink to &quot;3.解决分布式事务&quot;">​</a></h2><blockquote><p>分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴<code>CAP</code>定理和<code>BASE</code>理论，有两种解决思路。</p></blockquote><ul><li><p><strong>AP模式</strong>：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。</p></li><li><p><strong>CP模式</strong>：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态。</p></li><li><p>但不管是哪一种模式，都需要在子系统事务之间互相通讯，协调事务状态，也就是需要一个<strong>事务协调者(TC)</strong></p><ul><li><p>这里的子系统事务，称为<strong>分支事务</strong>；有关联的各个分支事务在一起称为<strong>全局事务</strong>。</p><p><img src="'+i+'" alt="image-20230111075810573"></p></li></ul></li></ul><h2 id="_1-seata介绍" tabindex="-1">1.Seata介绍 <a class="header-anchor" href="#_1-seata介绍" aria-label="Permalink to &quot;1.Seata介绍&quot;">​</a></h2><blockquote><p><code>Seata</code>是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。</p></blockquote><ul><li><p>官网地址：<a href="http://seata.io/%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3%E3%80%81%E6%92%AD%E5%AE%A2%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BA%86%E5%A4%A7%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%82" target="_blank" rel="noreferrer">http://seata.io/，其中的文档、播客中提供了大量的使用说明、源码分析。</a></p><p><img src="'+t+'" alt="image-20230111080348548"></p></li></ul><h2 id="_2-seata架构" tabindex="-1">2.Seata架构 <a class="header-anchor" href="#_2-seata架构" aria-label="Permalink to &quot;2.Seata架构&quot;">​</a></h2><ul><li><p>Seata事务管理中有三个重要的角色</p><ul><li><strong>TC (Transaction Coordinator) -</strong> **事务协调者：**维护全局和分支事务的状态，协调全局事务提交或回滚。</li><li><strong>TM (Transaction Manager) -</strong> **事务管理器：**定义全局事务的范围、开始全局事务、提交或回滚全局事务。</li><li><strong>RM (Resource Manager) -</strong> **资源管理器：**管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul></li><li><p>整体的架构如图</p><p><img src="'+o+`" alt="image-20230111081740759"></p></li><li><p>Seata基于上述架构提供了四种不同的分布式事务解决方案</p><ul><li>XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入</li><li>TCC模式：最终一致的分阶段事务模式，有业务侵入</li><li><strong>AT模式</strong>：最终一致的分阶段事务模式，无业务侵入，也是<code>Seata</code>的默认模式⭐</li><li>SAGA模式：长事务模式，有业务侵入</li></ul></li><li><p>无论哪种方案，都离不开TC，也就是事务的协调者。</p></li></ul><h2 id="_3-集成seata" tabindex="-1">3.集成Seata <a class="header-anchor" href="#_3-集成seata" aria-label="Permalink to &quot;3.集成Seata&quot;">​</a></h2><ol><li><p><strong>下载<code>Seata</code>并配置<code>registry.conf</code></strong></p><ul><li><p>这里使用的配置是<code>nacos</code>注册中心</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>registry {</span></span>
<span class="line"><span>  type = &quot;nacos&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  nacos {</span></span>
<span class="line"><span>    application = &quot;seata-tc-server&quot;</span></span>
<span class="line"><span>    serverAddr = &quot;127.0.0.1:8848&quot;</span></span>
<span class="line"><span>    group = &quot;DEFAULT_GROUP&quot;</span></span>
<span class="line"><span>    namespace = &quot;&quot;</span></span>
<span class="line"><span>    cluster = &quot;SH&quot;</span></span>
<span class="line"><span>    username = &quot;nacos&quot;</span></span>
<span class="line"><span>    password = &quot;nacos&quot;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>config {</span></span>
<span class="line"><span>  type = &quot;nacos&quot;</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  nacos {</span></span>
<span class="line"><span>    serverAddr = &quot;127.0.0.1:8848&quot;</span></span>
<span class="line"><span>    namespace = &quot;&quot;</span></span>
<span class="line"><span>    group = &quot;SEATA_GROUP&quot;</span></span>
<span class="line"><span>    username = &quot;nacos&quot;</span></span>
<span class="line"><span>    password = &quot;nacos&quot;</span></span>
<span class="line"><span>    dataId = &quot;seataServer.properties&quot;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>json</span></span></code></pre></div></li></ul></li><li><p><strong>在项目中引入依赖</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>&lt;!--seata--&gt;</span></span>
<span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;</span></span>
<span class="line"><span>    &lt;exclusions&gt;</span></span>
<span class="line"><span>        &lt;!--版本较低，1.3.0，因此排除--&gt; </span></span>
<span class="line"><span>        &lt;exclusion&gt;</span></span>
<span class="line"><span>            &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;</span></span>
<span class="line"><span>            &lt;groupId&gt;io.seata&lt;/groupId&gt;</span></span>
<span class="line"><span>        &lt;/exclusion&gt;</span></span>
<span class="line"><span>    &lt;/exclusions&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span>
<span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;io.seata&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;</span></span>
<span class="line"><span>    &lt;!--seata starter 采用1.4.2版本--&gt;</span></span>
<span class="line"><span>    &lt;version&gt;\${seata.version}&lt;/version&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span>
<span class="line"><span>xml</span></span></code></pre></div></li><li><p><strong>配置TC地址</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>seata:</span></span>
<span class="line"><span>  data-source-proxy-mode: AT # 配置数据源代理模式 默认AT</span></span>
<span class="line"><span>  registry: # TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span></span>
<span class="line"><span>    type: nacos # 注册中心类型 nacos</span></span>
<span class="line"><span>    nacos:</span></span>
<span class="line"><span>      server-addr: 127.0.0.1:8848 # nacos地址</span></span>
<span class="line"><span>      namespace: &quot;&quot; # namespace，默认为空</span></span>
<span class="line"><span>      group: DEFAULT_GROUP # 分组，默认是DEFAULT_GROUP</span></span>
<span class="line"><span>      application: seata-tc-server # seata服务名称</span></span>
<span class="line"><span>      username: nacos</span></span>
<span class="line"><span>      password: nacos</span></span>
<span class="line"><span>  tx-service-group: seata-demo # 事务组名称</span></span>
<span class="line"><span>  service:</span></span>
<span class="line"><span>    vgroup-mapping: # 事务组与cluster的映射关系</span></span>
<span class="line"><span>      seata-demo: SH</span></span>
<span class="line"><span>yml</span></span></code></pre></div></li></ol><h2 id="四、四种模式" tabindex="-1">四、四种模式 <a class="header-anchor" href="#四、四种模式" aria-label="Permalink to &quot;四、四种模式&quot;">​</a></h2><h2 id="_1-xa模式" tabindex="-1">1.XA模式 <a class="header-anchor" href="#_1-xa模式" aria-label="Permalink to &quot;1.XA模式&quot;">​</a></h2><blockquote><p>XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范 描述了全局的TM与局部的RM之间的接口，几乎所有主流的数据库都对 XA 规范 提供了支持。</p></blockquote><h3 id="_1-1-执行流程" tabindex="-1">1.1 执行流程 <a class="header-anchor" href="#_1-1-执行流程" aria-label="Permalink to &quot;1.1 执行流程&quot;">​</a></h3><blockquote><p>XA是规范，目前主流数据库都实现了这种规范，实现的原理都是基于两阶段提交。</p></blockquote><ul><li><p>正常情况下执行流程</p><p><img src="`+c+'" alt="image-20230111085348439"></p></li><li><p>异常情况下执行流程</p><p><img src="'+r+'" alt="image-20230111085714845"></p></li><li><p>一阶段：</p><ul><li>事务协调者通知每个事物参与者执行本地事务</li><li>本地事务执行完成后报告事务执行状态给事务协调者，此时事务不提交，继续持有数据库锁</li></ul></li><li><p>二阶段：</p><ul><li>事务协调者基于一阶段的报告来判断下一步操作 <ul><li>如果一阶段都成功，则通知所有事务参与者，提交事务</li><li>如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务</li></ul></li></ul></li></ul><h3 id="_1-2-xa模型" tabindex="-1">1.2 XA模型 <a class="header-anchor" href="#_1-2-xa模型" aria-label="Permalink to &quot;1.2 XA模型&quot;">​</a></h3><blockquote><p>Seata对原始的XA模式做了简单的封装和改造，以适应自己的事务模型，基本架构如下所示</p></blockquote><p><img src="'+d+`" alt="image-20230111090300945"></p><ul><li><p>RM一阶段的工作</p><ul><li>注册分支事务到TC</li><li>执行分支业务sql但不提交</li><li>报告执行状态到TC</li></ul></li><li><p>TC二阶段的工作</p><ul><li><p>TC检测各分支事务执行状态</p><ul><li><p>a.如果都成功，通知所有RM提交事务</p></li><li><p>b.如果有失败，通知所有RM回滚事务</p></li></ul></li></ul></li><li><p>RM二阶段的工作</p><ul><li>接收TC指令，提交或回滚事务</li></ul></li></ul><h3 id="_1-3-xa的优缺点" tabindex="-1">1.3 XA的优缺点 <a class="header-anchor" href="#_1-3-xa的优缺点" aria-label="Permalink to &quot;1.3 XA的优缺点&quot;">​</a></h3><ul><li><p>XA模式的优点是什么？</p><ul><li>事务的强一致性，满足ACID原则。</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul></li><li><p>XA模式的缺点是什么？</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务</li></ul></li></ul><h3 id="_1-4-具体实现" tabindex="-1">1.4 具体实现 <a class="header-anchor" href="#_1-4-具体实现" aria-label="Permalink to &quot;1.4 具体实现&quot;">​</a></h3><ol><li><p>修改每个参与事务的微服务的yml文件</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>seata:</span></span>
<span class="line"><span>  data-source-proxy-mode: XA</span></span>
<span class="line"><span>yml</span></span></code></pre></div></li><li><p>给发起全局事务的入口方法添加@GlobalTransactional注解</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>@GlobalTransactional</span></span>
<span class="line"><span>java</span></span></code></pre></div></li></ol><h2 id="_2-at模式⭐" tabindex="-1">2.AT模式⭐ <a class="header-anchor" href="#_2-at模式⭐" aria-label="Permalink to &quot;2.AT模式⭐&quot;">​</a></h2><blockquote><p>AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。</p></blockquote><h3 id="_2-1-at模型" tabindex="-1">2.1 AT模型 <a class="header-anchor" href="#_2-1-at模型" aria-label="Permalink to &quot;2.1 AT模型&quot;">​</a></h3><p><img src="`+u+'" alt="image-20230111092039993"></p><ul><li><p>阶段一<code>RM</code>的工作</p><ul><li>注册分支事务</li><li>记录<code>undo-log</code>（数据快照）</li><li>执行业务<code>sql</code>并提交</li><li>报告事务状态</li></ul></li><li><p>阶段二提交时RM的工作</p><ul><li>删除<code>undo-log</code>即可</li></ul></li><li><p>阶段二回滚时<code>RM</code>的工作</p><ul><li>根据<code>undo-log</code>恢复数据到更新前</li></ul></li></ul><h3 id="_2-2-执行流程" tabindex="-1">2.2 执行流程 <a class="header-anchor" href="#_2-2-执行流程" aria-label="Permalink to &quot;2.2 执行流程&quot;">​</a></h3><p>AT模式下，当前分支事务执行流程如下：</p><ul><li><p>一阶段：</p><ul><li>TM发起并注册全局事务到TC</li><li>TM调用分支事务</li><li>分支事务准备执行业务SQL</li><li>RM拦截业务SQL，根据where条件查询原始数据，形成快照。</li><li>RM执行业务SQL，提交本地事务，释放数据库锁。此时 <code>money = 90</code></li><li>RM报告本地事务状态给TC</li></ul></li><li><p>二阶段：</p><ul><li><p>TM通知TC事务结束</p></li><li><p>TC检查分支事务状态</p><ul><li><p>如果都成功，则立即删除快照</p></li><li><p>如果有分支事务失败，需要回滚。读取快照数据（<code>{&quot;id&quot;: 1, &quot;money&quot;: 100}</code>），将快照恢复到数据库。此时数据库再次恢复为100</p></li></ul></li></ul><p><img src="'+g+'" alt="image-20230111092644754"></p></li></ul><h3 id="_2-3-at与xa的区别" tabindex="-1">2.3 AT与XA的区别 <a class="header-anchor" href="#_2-3-at与xa的区别" aria-label="Permalink to &quot;2.3 AT与XA的区别&quot;">​</a></h3><ul><li>XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源。</li><li>XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚。</li><li>XA模式强一致；AT模式最终一致</li></ul><h3 id="_2-4-具体实现" tabindex="-1">2.4 具体实现 <a class="header-anchor" href="#_2-4-具体实现" aria-label="Permalink to &quot;2.4 具体实现&quot;">​</a></h3><ol><li><p>在微服务关联的数据表中导入以下SQL（<code>undo_log</code>）</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>DROP TABLE IF EXISTS `undo_log`;</span></span>\n<span class="line"><span>CREATE TABLE `undo_log`  (</span></span>\n<span class="line"><span>  `branch_id` bigint(20) NOT NULL COMMENT &#39;branch transaction id&#39;,</span></span>\n<span class="line"><span>  `xid` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT &#39;global transaction id&#39;,</span></span>\n<span class="line"><span>  `context` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT &#39;undo_log context,such as serialization&#39;,</span></span>\n<span class="line"><span>  `rollback_info` longblob NOT NULL COMMENT &#39;rollback info&#39;,</span></span>\n<span class="line"><span>  `log_status` int(11) NOT NULL COMMENT &#39;0:normal status,1:defense status&#39;,</span></span>\n<span class="line"><span>  `log_created` datetime(6) NOT NULL COMMENT &#39;create datetime&#39;,</span></span>\n<span class="line"><span>  `log_modified` datetime(6) NOT NULL COMMENT &#39;modify datetime&#39;,</span></span>\n<span class="line"><span>  UNIQUE INDEX `ux_undo_log`(`xid`, `branch_id`) USING BTREE</span></span>\n<span class="line"><span>) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = &#39;AT transaction mode undo table&#39; ROW_FORMAT = Compact;</span></span>\n<span class="line"><span>sql</span></span></code></pre></div></li><li><p>在TC服务关联的数据库导入以下SQL（<code>lock_table</code>）</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>DROP TABLE IF EXISTS `lock_table`;</span></span>\n<span class="line"><span>CREATE TABLE `lock_table`  (</span></span>\n<span class="line"><span>  `row_key` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span></span>\n<span class="line"><span>  `xid` varchar(96) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span></span>\n<span class="line"><span>  `transaction_id` bigint(20) NULL DEFAULT NULL,</span></span>\n<span class="line"><span>  `branch_id` bigint(20) NOT NULL,</span></span>\n<span class="line"><span>  `resource_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span></span>\n<span class="line"><span>  `table_name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span></span>\n<span class="line"><span>  `pk` varchar(36) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span></span>\n<span class="line"><span>  `gmt_create` datetime NULL DEFAULT NULL,</span></span>\n<span class="line"><span>  `gmt_modified` datetime NULL DEFAULT NULL,</span></span>\n<span class="line"><span>  PRIMARY KEY (`row_key`) USING BTREE,</span></span>\n<span class="line"><span>  INDEX `idx_branch_id`(`branch_id`) USING BTREE</span></span>\n<span class="line"><span>) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>SET FOREIGN_KEY_CHECKS = 1;</span></span>\n<span class="line"><span>sql</span></span></code></pre></div></li><li><p>修改每个参与事务的微服务的yml文件</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>seata:</span></span>\n<span class="line"><span>  data-source-proxy-mode: AT # 默认就是AT</span></span>\n<span class="line"><span>yml</span></span></code></pre></div></li></ol><h2 id="_3-tcc模式" tabindex="-1">3.TCC模式 <a class="header-anchor" href="#_3-tcc模式" aria-label="Permalink to &quot;3.TCC模式&quot;">​</a></h2><p>太鸡儿难了，我giao，我不配学</p><h2 id="_4-saga模式" tabindex="-1">4.SAGA模式 <a class="header-anchor" href="#_4-saga模式" aria-label="Permalink to &quot;4.SAGA模式&quot;">​</a></h2><p>这个老师也没讲，芜湖那我就不学了</p><h2 id="_5-四种模式对比" tabindex="-1">5…四种模式对比 <a class="header-anchor" href="#_5-四种模式对比" aria-label="Permalink to &quot;5…四种模式对比&quot;">​</a></h2><ul><li><p>一致性：能否保证事务的一致性？强一致还是最终一致？</p></li><li><p>隔离性：事务之间的隔离性如何？</p></li><li><p>代码侵入：是否需要对业务代码改造？</p></li><li><p>性能：有无性能损耗？</p></li><li><p>场景：常见的业务场景</p><p><img src="'+h+'" alt="image-20230111093618099"></p></li></ul>',57),A=[m];function b(T,E,q,C,L,f){return n(),s("div",null,A)}const S=a(_,[["render",b]]);export{v as __pageData,S as default};

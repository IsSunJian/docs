import{_ as i,c as s,o as a,a4 as n}from"./chunks/framework.K9vKjHgL.js";const t="/docs/assets/BlockingQueue-01.C7MBuOBG.png",l="/docs/assets/BlockingQueue-02.Bxioau4j.png",h="/docs/assets/BlockingQueue-03.Cn6vFsQu.png",E=JSON.parse('{"title":"吊打Java并发面试官之BlockingQueue","description":"吊打Java并发面试官之BlockingQueue","frontmatter":{"title":"吊打Java并发面试官之BlockingQueue","shortTitle":"BlockingQueue","description":"吊打Java并发面试官之BlockingQueue","category":["Java核心"],"tag":["Java并发编程"],"head":[["meta",{"name":"keywords","content":"Java,并发编程,多线程,Thread,BlockingQueue"}]]},"headers":[],"relativePath":"backend/tobetter/thread/BlockingQueue.md","filePath":"backend/tobetter/thread/BlockingQueue.md"}'),k={name:"backend/tobetter/thread/BlockingQueue.md"},e=n('<p>最常用的&quot;<strong>生产者-消费者</strong>&quot;问题中，队列通常被视作线程间操作的数据容器，这样，可以对各个模块的业务功能进行解耦，生产者将“生产”出来的数据放置在数据容器中，而消费者仅仅只需要在“数据容器”中进行获取数据即可，这样生产者线程和消费者线程就能够进行解耦，只专注于自己的业务功能即可。</p><p>阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是BlockingQueue提供了可阻塞的插入和移除的方法。<strong>当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止</strong>。</p><h2 id="基本操作" tabindex="-1">基本操作 <a class="header-anchor" href="#基本操作" aria-label="Permalink to &quot;基本操作&quot;">​</a></h2><p>BlockingQueue基本操作总结如下（此图来源于JAVA API文档）：</p><img src="'+t+`"><p>BlockingQueue继承于Queue接口，因此，对数据元素的基本操作有：</p><p>1）插入元素</p><ol><li>add(E e) ：往队列插入数据，当队列满时，插入元素时会抛出IllegalStateException异常；</li><li>offer(E e)：当往队列插入数据时，插入成功返回<code>true</code>，否则则返回<code>false</code>。当队列满时不会抛出异常；</li></ol><p>2）删除元素</p><ol><li>remove(Object o)：从队列中删除数据，成功则返回<code>true</code>，否则为<code>false</code></li><li>poll：删除数据，当队列为空时，返回null；</li></ol><p>3）查看元素</p><ol><li>element：获取队头元素，如果队列为空时则抛出NoSuchElementException异常；</li><li>peek：获取队头元素，如果队列为空则抛出NoSuchElementException异常</li></ol><p>BlockingQueue具有的特殊操作：</p><p>1）插入数据：</p><ol><li>put：当阻塞队列容量已经满时，往阻塞队列插入数据的线程会被阻塞，直至阻塞队列已经有空余的容量可供使用；</li><li><code>offer(E e, long timeout, TimeUnit unit)</code>：若阻塞队列已经满时，同样会阻塞插入数据的线程，直至阻塞队列已经有空余的地方，与put方法不同的是，该方法会有一个超时时间，若超过当前给定的超时时间，插入数据的线程会退出；</li></ol><p>2）删除数据</p><ol><li><code>take()</code>：当阻塞队列为空时，获取队头数据的线程会被阻塞；</li><li><code>poll(long timeout, TimeUnit unit)</code>：当阻塞队列为空时，获取数据的线程会被阻塞，另外，如果被阻塞的线程超过了给定的时长，该线程会退出</li></ol><h2 id="常用的blockingqueue" tabindex="-1">常用的BlockingQueue <a class="header-anchor" href="#常用的blockingqueue" aria-label="Permalink to &quot;常用的BlockingQueue&quot;">​</a></h2><p>实现BlockingQueue接口的有<code>ArrayBlockingQueue, DelayQueue, LinkedBlockingDeque, LinkedBlockingQueue, LinkedTransferQueue, PriorityBlockingQueue, SynchronousQueue</code>，而这几种常见的阻塞队列也是在实际编程中会常用的，下面对这几种常见的阻塞队列进行说明：</p><h3 id="arrayblockingqueue" tabindex="-1">ArrayBlockingQueue <a class="header-anchor" href="#arrayblockingqueue" aria-label="Permalink to &quot;ArrayBlockingQueue&quot;">​</a></h3><p><strong>ArrayBlockingQueue</strong>是由数组实现的有界阻塞队列。该队列命令元素FIFO（先进先出）。因此，对头元素时队列中存在时间最长的数据元素，而对尾数据则是当前队列最新的数据元素。ArrayBlockingQueue可作为“有界数据缓冲区”，生产者插入数据到队列容器中，并由消费者提取。ArrayBlockingQueue一旦创建，容量不能改变。</p><p>当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p><p>ArrayBlockingQueue默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到ArrayBlockingQueue。而非公平性则是指访问ArrayBlockingQueue的顺序不是遵守严格的时间顺序，有可能存在，一旦ArrayBlockingQueue可以被访问时，长时间阻塞的线程依然无法访问到ArrayBlockingQueue。<strong>如果保证公平性，通常会降低吞吐量</strong>。如果需要获得公平性的ArrayBlockingQueue，可采用如下代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> ArrayBlockingQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F6F6F4;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">&gt; blockingQueue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;--shiki-light-font-weight:inherit;--shiki-dark-font-weight:bold;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> ArrayBlockingQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F6F6F4;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">);</span></span></code></pre></div><p>ArrayBlockingQueue的主要属性如下:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">/** The queued items */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">final</span><span style="--shiki-light:#D73A49;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">[] items;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">/** items index for next take, poll, peek or remove */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> takeIndex;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">/** items index for next put, offer, or add */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> putIndex;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">/** Number of elements in the queue */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> count;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">/*</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;"> * Concurrency control uses the classic two-condition algorithm</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;"> * found in any textbook.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;"> */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">/** Main lock guarding all access */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">final</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> lock;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">/** Condition for waiting takes */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> Condition</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> notEmpty;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">/** Condition for waiting puts */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> Condition</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> notFull;</span></span></code></pre></div><p>从源码中可以看出ArrayBlockingQueue内部是采用数组进行数据存储的（<code>属性items</code>），为了保证线程安全，采用的是<code>ReentrantLock lock</code>，为了保证可阻塞式的插入删除数据利用的是Condition，当获取数据的消费者线程被阻塞时会将该线程放置到notEmpty等待队列中，当插入数据的生产者线程被阻塞时，会将该线程放置到notFull等待队列中。而notEmpty和notFull等中要属性在构造方法中进行创建：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;"> ArrayBlockingQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> capacity, </span><span style="--shiki-light:#D73A49;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> fair) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> (capacity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">        throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;--shiki-light-font-weight:inherit;--shiki-dark-font-weight:bold;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;"> IllegalArgumentException</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">.items </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;--shiki-light-font-weight:inherit;--shiki-dark-font-weight:bold;"> new</span><span style="--shiki-light:#D73A49;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">[capacity];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    lock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;--shiki-light-font-weight:inherit;--shiki-dark-font-weight:bold;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">(fair);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    notEmpty </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> lock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">newCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    notFull </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">  lock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">newCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">}</span></span></code></pre></div><p>接下来，主要看看可阻塞式的put和take方法是怎样实现的。</p><h4 id="_1-put方法详解" tabindex="-1">1）put方法详解 <a class="header-anchor" href="#_1-put方法详解" aria-label="Permalink to &quot;1）put方法详解&quot;">​</a></h4><p><code> put(E e)</code>方法源码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;"> put</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> e) throws InterruptedException {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">    checkNotNull</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">(e);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    final</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> lock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">.lock;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    lock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">lockInterruptibly</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    try</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">		//如果当前队列已满，将线程移入到notFull等待队列中</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> (count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> items.length)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">            notFull.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">		//满足插入数据的要求，直接进行入队操作</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">        enqueue</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">(e);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">        lock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">}</span></span></code></pre></div><p>该方法的逻辑很简单，当队列已满时（<code>count == items.length</code>）将线程移入到notFull等待队列中，如果当前满足插入数据的条件，就可以直接调用<code> enqueue(e)</code>插入数据元素。enqueue方法源码为：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;"> enqueue</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> x) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">    // assert lock.getHoldCount() == 1;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">    // assert items[putIndex] == null;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    final</span><span style="--shiki-light:#D73A49;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">[] items </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">.items;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">	//插入数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    items[putIndex] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> x;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">putIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> items.length)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">        putIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">	//通知消费者线程，当前队列中有数据可供消费</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    notEmpty.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">signal</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">}</span></span></code></pre></div><p>enqueue方法的逻辑同样也很简单，先完成插入数据，即往数组中添加数据（<code>items[putIndex] = x</code>），然后通知被阻塞的消费者线程，当前队列中有数据可供消费（<code>notEmpty.signal()</code>）。</p><h4 id="_2-take方法详解" tabindex="-1">2）take方法详解 <a class="header-anchor" href="#_2-take方法详解" aria-label="Permalink to &quot;2）take方法详解&quot;">​</a></h4><p>take方法源码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> E</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;"> take</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">() throws InterruptedException {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    final</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> lock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">.lock;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    lock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">lockInterruptibly</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    try</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">		//如果队列为空，没有数据，将消费者线程移入等待队列中</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> (count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">            notEmpty.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">		//获取数据</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">        return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;"> dequeue</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">        lock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">}</span></span></code></pre></div><p>take方法也主要做了两步：</p><ol><li>如果当前队列为空的话，则将获取数据的消费者线程移入到等待队列中；</li><li>若队列不为空则获取数据，即完成出队操作<code>dequeue</code>。dequeue方法源码为：</li></ol><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">private</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> E</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;"> dequeue</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">    // assert lock.getHoldCount() == 1;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">    // assert items[takeIndex] != null;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    final</span><span style="--shiki-light:#D73A49;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">[] items </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">.items;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">SuppressWarnings</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#DEE492;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#E7EE98;">unchecked</span><span style="--shiki-light:#032F62;--shiki-dark:#DEE492;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">	//获取数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    E</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> (E) items[takeIndex];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    items[takeIndex] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">takeIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> items.length)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">        takeIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> (itrs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">        itrs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">elementDequeued</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">    //通知被阻塞的生产者线程</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">	notFull.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">signal</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> x;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">}</span></span></code></pre></div><p>dequeue方法也主要做了两件事情：</p><ol><li>获取队列中的数据，即获取数组中的数据元素（<code>(E) items[takeIndex]</code>）；</li><li>通知notFull等待队列中的线程，使其由等待队列移入到同步队列中，使其能够有机会获得lock，并执行完成功退出。</li></ol><p>从以上分析，可以看出put和take方法主要是通过condition的通知机制来完成可阻塞式的插入数据和获取数据。在理解ArrayBlockingQueue后再去理解LinkedBlockingQueue就很容易了。</p><h3 id="linkedblockingqueue" tabindex="-1">LinkedBlockingQueue <a class="header-anchor" href="#linkedblockingqueue" aria-label="Permalink to &quot;LinkedBlockingQueue&quot;">​</a></h3><p>LinkedBlockingQueue是用链表实现的有界阻塞队列，同样满足FIFO的特性，与ArrayBlockingQueue相比起来具有更高的吞吐量，为了防止LinkedBlockingQueue容量迅速增，损耗大量内存。通常在创建LinkedBlockingQueue对象时，会指定其大小，如果未指定，容量等于Integer.MAX_VALUE</p><p>LinkedBlockingQueue的主要属性有：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">/** Current number of elements */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> AtomicInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;--shiki-light-font-weight:inherit;--shiki-dark-font-weight:bold;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;"> AtomicInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;"> * Head of linked list.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;"> * Invariant: head.item == null</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">transient</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> Node</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F6F6F4;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">&gt; head;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;"> * Tail of linked list.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;"> * Invariant: last.next == null</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;"> transient</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> Node</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F6F6F4;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">&gt; last;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">/** Lock held by take, poll, etc */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> takeLock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;--shiki-light-font-weight:inherit;--shiki-dark-font-weight:bold;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">/** Wait queue for waiting takes */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> Condition</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> notEmpty </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> takeLock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">newCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">/** Lock held by put, offer, etc */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> putLock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;--shiki-light-font-weight:inherit;--shiki-dark-font-weight:bold;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">/** Wait queue for waiting puts */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> Condition</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> notFull </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> putLock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">newCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span></code></pre></div><p>可以看出与ArrayBlockingQueue主要的区别是，LinkedBlockingQueue在插入数据和删除数据时分别是由两个不同的lock（<code>takeLock</code>和<code>putLock</code>）来控制线程安全的，因此，也由这两个lock生成了两个对应的condition（<code>notEmpty</code>和<code>notFull</code>）来实现可阻塞的插入和删除数据。并且，采用了链表的数据结构来实现队列，Node结点的定义为：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#97E1F1;"> Node</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F6F6F4;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    E</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> item;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">    /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">     * One of:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">     * - the real successor Node</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">     * - this Node, meaning the successor is head.next</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">     * - null, meaning there is no successor (this is the last node)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">     */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    Node</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F6F6F4;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">&gt; next;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">    Node</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">E</span><span style="--shiki-light:#E36209;--shiki-dark:#FFB86C;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">) { item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> x; }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">}</span></span></code></pre></div><p>接下来，我们也同样来看看put方法和take方法的实现。</p><h4 id="_1-put方法详解-1" tabindex="-1">1）put方法详解 <a class="header-anchor" href="#_1-put方法详解-1" aria-label="Permalink to &quot;1）put方法详解&quot;">​</a></h4><p>put方法源码为:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;"> put</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> e) throws InterruptedException {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> (e </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;--shiki-light-font-weight:inherit;--shiki-dark-font-weight:bold;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;"> NullPointerException</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">    // Note: convention in all put/take/etc is to preset local var</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">    // holding count negative to indicate failure unless set.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    Node</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F6F6F4;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">&gt; node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;--shiki-light-font-weight:inherit;--shiki-dark-font-weight:bold;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> Node</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F6F6F4;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">&gt;(e);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    final</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> putLock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">.putLock;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    final</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> AtomicInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">.count;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    putLock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">lockInterruptibly</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    try</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">        /*</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">         * Note that count is used in wait guard even though it is</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">         * not protected by lock. This works because count can</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">         * only decrease at this point (all other puts are shut</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">         * out by lock), and we (or some other waiting put) are</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">         * signalled if it ever changes from capacity. Similarly</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">         * for all other uses of count in other wait guards.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">         */</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">		//如果队列已满，则阻塞当前线程，将其移入等待队列</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> (count.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> capacity) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">            notFull.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">		//入队操作，插入数据</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">        enqueue</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">(node);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">        c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> count.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">getAndIncrement</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">		//若队列满足插入数据的条件，则通知被阻塞的生产者线程</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> (c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> capacity)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">            notFull.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">signal</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">        putLock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> (c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">        signalNotEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">}</span></span></code></pre></div><p>put方法的逻辑也同样很容易理解，可见注释。基本上和ArrayBlockingQueue的put方法一样。</p><h4 id="_2-take方法" tabindex="-1">2）take方法 <a class="header-anchor" href="#_2-take方法" aria-label="Permalink to &quot;2）take方法&quot;">​</a></h4><p>源码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> E</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;"> take</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">() throws InterruptedException {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    E</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> x;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    final</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> AtomicInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">.count;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    final</span><span style="--shiki-light:#24292E;--shiki-dark:#97E1F1;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> takeLock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">.takeLock;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    takeLock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">lockInterruptibly</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    try</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">		//当前队列为空，则阻塞当前线程，将其移入到等待队列中，直至满足条件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> (count.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">            notEmpty.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">		//移除队头元素，获取数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">        x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;"> dequeue</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">        c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> count.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">getAndDecrement</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7B7F8B;">        //如果当前满足移除元素的条件，则通知被阻塞的消费者线程</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">		if</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> (c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#BF9EEE;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">            notEmpty.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">signal</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">        takeLock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> (c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> capacity)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#62E884;">        signalNotFull</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F286C4;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;"> x;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F6F6F4;">}</span></span></code></pre></div><p>take方法的主要逻辑请见于注释，也很容易理解。</p><p>** ArrayBlockingQueue与LinkedBlockingQueue的比较**</p><p><strong>相同点</strong>：ArrayBlockingQueue和LinkedBlockingQueue都是通过condition通知机制来实现可阻塞式插入和删除元素，并满足线程安全的特性；</p><p><strong>不同点</strong>：</p><ol><li>ArrayBlockingQueue底层是采用的数组进行实现，而LinkedBlockingQueue则是采用链表数据结构；</li><li>ArrayBlockingQueue插入和删除数据，只采用了一个lock，而LinkedBlockingQueue则是在插入和删除分别采用了<code>putLock</code>和<code>takeLock</code>，这样可以降低线程由于线程无法获取到lock而进入WAITING状态的可能性，从而提高了线程并发执行的效率。</li></ol><h3 id="priorityblockingqueue" tabindex="-1">PriorityBlockingQueue <a class="header-anchor" href="#priorityblockingqueue" aria-label="Permalink to &quot;PriorityBlockingQueue&quot;">​</a></h3><p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现compareTo()方法来指定元素排序规则，或者初始化时通过构造器参数Comparator来指定排序规则。</p><h3 id="synchronousqueue" tabindex="-1">SynchronousQueue <a class="header-anchor" href="#synchronousqueue" aria-label="Permalink to &quot;SynchronousQueue&quot;">​</a></h3><p>SynchronousQueue每个插入操作必须等待另一个线程进行相应的删除操作，因此，SynchronousQueue实际上没有存储任何数据元素，因为只有线程在删除数据时，其他线程才能插入数据，同样的，如果当前有线程在插入数据时，线程才能删除数据。SynchronousQueue也可以通过构造器参数来为其指定公平性。</p><h3 id="linkedtransferqueue" tabindex="-1">LinkedTransferQueue <a class="header-anchor" href="#linkedtransferqueue" aria-label="Permalink to &quot;LinkedTransferQueue&quot;">​</a></h3><p>LinkedTransferQueue是一个由链表数据结构构成的无界阻塞队列，由于该队列实现了TransferQueue接口，与其他阻塞队列相比主要有以下不同的方法：</p><p><strong>transfer(E e)</strong> 如果当前有线程（消费者）正在调用take()方法或者可延时的poll()方法进行消费数据时，生产者线程可以调用transfer方法将数据传递给消费者线程。如果当前没有消费者线程的话，生产者线程就会将数据插入到队尾，直到有消费者能够进行消费才能退出；</p><p><strong>tryTransfer(E e)</strong> tryTransfer方法如果当前有消费者线程（调用take方法或者具有超时特性的poll方法）正在消费数据的话，该方法可以将数据立即传送给消费者线程，如果当前没有消费者线程消费数据的话，就立即返回<code>false</code>。因此，与transfer方法相比，transfer方法是必须等到有消费者线程消费数据时，生产者线程才能够返回。而tryTransfer方法能够立即返回结果退出。</p><p><code>tryTransfer(E e,long timeout,imeUnit unit)</code> 与transfer基本功能一样，只是增加了超时特性，如果数据才规定的超时时间内没有消费者进行消费的话，就返回<code>false</code>。</p><h3 id="linkedblockingdeque" tabindex="-1">LinkedBlockingDeque <a class="header-anchor" href="#linkedblockingdeque" aria-label="Permalink to &quot;LinkedBlockingDeque&quot;">​</a></h3><p>LinkedBlockingDeque是基于链表数据结构的有界阻塞双端队列，如果在创建对象时为指定大小时，其默认大小为Integer.MAX_VALUE。与LinkedBlockingQueue相比，主要的不同点在于，LinkedBlockingDeque具有双端队列的特性。LinkedBlockingDeque基本操作如下图所示（来源于java文档）</p><img src="`+l+'"><p>如上图所示，LinkedBlockingDeque的基本操作可以分为四种类型：</p><ol><li>特殊情况，抛出异常；</li><li>特殊情况，返回特殊值如null或者false；</li><li>当线程不满足操作条件时，线程会被阻塞直至条件满足；</li><li>操作具有超时特性。</li></ol><p>另外，LinkedBlockingDeque实现了BlockingDueue接口而LinkedBlockingQueue实现的是BlockingQueue，这两个接口的主要区别如下图所示（来源于java文档）：</p><img src="'+h+'"><p>从上图可以看出，两个接口的功能是可以等价使用的，比如BlockingQueue的add方法和BlockingDeque的addLast方法的功能是一样的。</p><h3 id="delayqueue" tabindex="-1">DelayQueue <a class="header-anchor" href="#delayqueue" aria-label="Permalink to &quot;DelayQueue&quot;">​</a></h3><p>DelayQueue是一个存放实现Delayed接口的数据的无界阻塞队列，只有当数据对象的延时时间达到时才能插入到队列进行存储。如果当前所有的数据都还没有达到创建时所指定的延时期，则队列没有队头，并且线程通过poll等方法获取数据元素则返回null。所谓数据延时期满时，则是通过Delayed接口的<code>getDelay(TimeUnit.NANOSECONDS)</code>来进行判定，如果该方法返回的是小于等于0则说明该数据元素的延时期已满。</p><hr><blockquote><p>内容大部分来源以下三个开源仓库：</p><ul><li><a href="http://concurrent.redspider.group/" target="_blank" rel="noreferrer">深入浅出 Java 多线程</a></li><li><a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noreferrer">并发编程知识总结</a></li><li><a href="https://github.com/CoderLeixiaoshuai/java-eight-part" target="_blank" rel="noreferrer">Java八股文</a></li></ul></blockquote><hr>',85),p=[e];function r(F,d,g,o,y,c){return a(),s("div",null,p)}const C=i(k,[["render",r]]);export{E as __pageData,C as default};

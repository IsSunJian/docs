import{_ as s,c as i,o as a,a4 as e}from"./chunks/framework.-JfgED0h.js";const n="/docs/assets/moxing-20230408110408.C8GdhlKV.png",t="/docs/assets/moxing-20230408110433.CyUchHKq.png",l="/docs/assets/buffer-channel-selector-20230406182813.CoP48WQi.png",h="/docs/assets/moxing-20230408114300.DVXS1zZb.png",p="/docs/assets/moxing-20230408115158.BpkfsIJ_.png",k="/docs/assets/moxing-20230408115251.AGg-q5_n.png",r="/docs/assets/moxing-20230408115328.B01mDkU5.png",m=JSON.parse('{"title":"一文彻底理解Java IO模型（阻塞IO非阻塞IO/IO多路复用）","description":"I/O 模型包括阻塞 I/O、非阻塞 I/O、多路复用、信号驱动和异步 I/O。阻塞 I/O 操作等待数据传输完成，非阻塞 I/O 操作不等待，可执行其他任务。多路复用适用于高并发和高吞吐量场景，信号驱动依赖信号通知应用程序。异步 I/O 由内核负责数据传输，应用程序无需等待。","frontmatter":{"title":"一文彻底理解Java IO模型（阻塞IO非阻塞IO/IO多路复用）","shortTitle":"Java IO模型","category":["Java核心"],"tag":["Java NIO"],"description":"I/O 模型包括阻塞 I/O、非阻塞 I/O、多路复用、信号驱动和异步 I/O。阻塞 I/O 操作等待数据传输完成，非阻塞 I/O 操作不等待，可执行其他任务。多路复用适用于高并发和高吞吐量场景，信号驱动依赖信号通知应用程序。异步 I/O 由内核负责数据传输，应用程序无需等待。","author":"沉默王二","head":[["meta",{"name":"keywords","content":"IO模型, 阻塞IO, 非阻塞IO, 多路复用, 信号驱动, 异步IO,java,nio"}]]},"headers":[],"relativePath":"backend/tobetter/nio/moxing.md","filePath":"backend/tobetter/nio/moxing.md"}'),o={name:"backend/tobetter/nio/moxing.md"},F=e("",52),d=[F];function c(g,y,I,O,E,C){return a(),i("div",null,d)}const f=s(o,[["render",c]]);export{m as __pageData,f as default};

import{_ as n,E as h,c as p,m as i,a as s,J as e,w as l,a4 as a,o as r}from"./chunks/framework.K9vKjHgL.js";const v=JSON.parse('{"title":"React 模拟面试题 2023 版","description":"","frontmatter":{"author":"HearLing"},"headers":[],"relativePath":"interview/frontend/react-summary/index.md","filePath":"interview/frontend/react-summary/index.md"}'),o={name:"interview/frontend/react-summary/index.md"},k=a("",9),d=i("strong",null,"答案仅供参考",-1),c=i("strong",null,"答案会详略得当，不会面面俱到",-1),u=a("",43),F=a("",11),g=i("ul",null,[i("li",null,[i("p",null,"React 主要使用 diff 队列保存需要更新哪些 DOM，得到 patch 树，再统一操作批量更新 DOM。")]),i("li",null,[i("p",null,"Vue Diff 使用双向链表，边对比，边更新 DOM。")])],-1),y=i("blockquote",null,[i("p",null,"注意两者处于不同赛道，不存在谁取代谁这一说法，别踩一捧一。")],-1),m=i("ul",null,[i("li",null,[i("p",null,"React 只关注底层，上层应用解决方案交给社区，造就了 React 社区繁荣，同时 React 团队有更多时间专注底层。未来 React 的发展依然会在 函数式编程 这个核心思想的下进行升级。")]),i("li",null,[i("p",null,"Vue 提供了一揽子全家桶解决方案，比如 Vuex、Vue-Router、Vue-CLI、Vutur 工具等。减少选择困难症，只需认准官方给出的解决方案即可。Vue 依然会定位简单易上手（渐进式开发），依然是考虑通过依赖收集来实现数据可变。")])],-1),b=a("",6),E=a("",10),f=i("ul",null,[i("li",null,"Store，Store 存放应用程序的状态，并且有帮助函数来访问这些状态。Store 可以用来聆听变化和发送 action。Store 只有一个。"),i("li",null,"Reducers，数据的状态是通过 reducer 函数来改变的。"),i("li",null,"Actions，Actions 代表的是一个对象。有两部分，一个是 action 本身，另一个就是它的 payload。简单说就是对哪些数据进行哪些操作。"),i("li",null,"React-Redux，Redux 本身和 React 没有关系，只是数据处理中心，是 React-Redux 让他们联系在一起。React-rRedux 提供两个方法：connect 和 Provider。")],-1),_=a("",25);function C(R,x,D,q,S,A){const t=h("font");return r(),p("div",null,[k,i("p",null,[s("3、"),e(t,{color:"red"},{default:l(()=>[d]),_:1}),s(),c,s("。我更偏向于告诉你，这个题第一层你可以怎么展开，第二层在你展开的这几点各自下面的重要点又是什么。至于你要不要扩充各个层级的点，以及要不要更深入增加层级，就是需要自己去思考和研究的了。")]),u,i("details",null,[F,i("p",null,[s("6、"),e(t,{color:"gray"},{default:l(()=>[s("diff 算法实现")]),_:1})]),g,i("p",null,[s("7、"),e(t,{color:"gray"},{default:l(()=>[s("社区和未来发展")]),_:1})]),y,m]),b,i("details",null,[E,e(t,{color:"gray"},{default:l(()=>[s("另外一些需要知道的")]),_:1}),f]),_])}const M=n(o,[["render",C]]);export{v as __pageData,M as default};

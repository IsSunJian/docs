import{_ as p,c as n,o as i,a4 as t}from"./chunks/framework.K9vKjHgL.js";const o="/docs/assets/image-20210713202807818.BryoKkTv.png",l="/docs/assets/image-20210713203124797.DXfq9-uO.png",r="/docs/assets/image-20210713203753373.BtsTKmSG.png",c="/docs/assets/image-20210713204155887.WQV8r4iS.png",d="/docs/assets/image-20210713205003790.C9AcC48K.png",a="/docs/assets/image-20210713210800950.B_bX5bJ_.png",g="/docs/assets/image-20210713211009593.Ch3aDj9F.png",u="/docs/assets/image-20210713211417049.DbW3AN6p.png",m="/docs/assets/image-20210713211550169.Ct5QYWyT.png",h="/docs/assets/image-20210713211657319.DJOk4wHu.png",b="/docs/assets/image-20210713211814094.C0yPzCnE.png",_="/docs/assets/image-20210713212656887.DPvU4Nsb.png",v="/docs/assets/image-20210713212349272.CYMvBkRU.png",k="/docs/assets/image-20210713212336185.D-pLYZZN.png",q="/docs/assets/image-20210713212513324.DPon4ZtM.png",f="/docs/assets/image-20210713220736408.fQBSY4vj.png",C="/docs/assets/image-20210713213312278.DAjKr-Yv.png",y="/docs/assets/image-20210713212749575.D_lGnn1k.png",B="/docs/assets/image-20210713212901725.DOjW9zX-.png",P="/docs/assets/image-20210713213146089.B8xJUUvS.png",x="/docs/assets/image-20210713213213075.BM-8uufx.png",S="/docs/assets/image-20210713213959569.BlHMJuLT.png",R="/docs/assets/image-20210713214404481.DFCW1UXE.png",A="/docs/assets/image-20210713214925388.CqsKkuPX.png",I="/docs/assets/image-20210713220104956.B4eh1SK9.png",N="/docs/assets/image-20210713220509769.Cmt_9NcF.png",E="/docs/assets/image-20210713220605881.BWVDHKlg.png",D="/docs/assets/image-20210713220857396.DlBr-IvD.png",T="/docs/assets/image-20210713221339022.B8yK5STD.png",s="/docs/assets/sureka-client-register.DcPU_0HL.jpg",L="/docs/assets/image-20210713222656562.CZ0hKHCU.png",w="/docs/assets/image-20210713222757702.BCKTi6p8.png",O="/docs/assets/image-20210713222841951.C5yCxTta.png",H="/docs/assets/image-20210713223041491.C9VrB6hU.png",Z="/docs/assets/image-20210713223150650.CXg8LYfu.png",K="/docs/assets/image-20210713224049419.epvkHipW.png",U="/docs/assets/image-20210713224245731.CuHX9XmT.png",j="/docs/assets/image-20210713224517686.BjnNQ_Kk.png",W="/docs/assets/1525620483637.Cr1QPLCp.png",F="/docs/assets/1525620787090.kUwOg73S.png",e="/docs/assets/1525620835911.auOVTot8.png",M="/docs/assets/1544361421671.CfNtli88.png",V="/docs/assets/1525622652849.zkiDRi1A.png",X="/docs/assets/1525622699666.4hsaY24i.png",Y="/docs/assets/1525622754316.DEBbnbu7.png",J="/docs/assets/image-20210713224724673.Dm2dHk_R.png",Q="/docs/assets/image-20210713225653000.B7jbcPDj.png",z="/docs/assets/image-20210713231439607.BSEcRx7A.png",$="/docs/assets/image-20210713232522531.D-fPRAbf.png",G="/docs/assets/image-20210713232658928.C1qKury9.png",aa="/docs/assets/image-20210713232916215.lu6fILHh.png",sa="/docs/assets/image-20210713233528982.BtWNNrMK.png",ea="/docs/assets/image-20210713233727923.YMRIxfy6.png",pa="/docs/assets/image-20210713235133225.Bw_3LTsp.png",na="/docs/assets/image-20210713235235219.Bn5RECUi.png",ia="/docs/assets/image-20210714000101516.BV0k7SWn.png",ta="/docs/assets/image-20210714000414781.Dy-QK02g.png",oa="/docs/assets/image-20210714000440143.Dsay4KSP.png",la="/docs/assets/image-20210714000505928.CSqXEn1c.png",ra="/docs/assets/image-20210714000522913.Be6ZLiTC.png",ca="/docs/assets/image-20210714000830703.Bjoin657.png",da="/docs/assets/image-20210714000837140.AHBCBbzS.png",ga="/docs/assets/image-20210714000941256.DACBBwfV.png",ua="/docs/assets/image-20210714001728017.Bnp9SKfP.png",Pa=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"backend/spring/SpringCloud01.md","filePath":"backend/spring/SpringCloud01.md"}'),ma={name:"backend/spring/SpringCloud01.md"},ha=t('<h2 id="springcloud01" tabindex="-1">SpringCloud01 <a class="header-anchor" href="#springcloud01" aria-label="Permalink to &quot;SpringCloud01&quot;">​</a></h2><p>随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？</p><p><strong>学习目标</strong>:了解微服务架构的优缺点 🎯</p><h2 id="_1-认识微服务" tabindex="-1">1.认识微服务 <a class="header-anchor" href="#_1-认识微服务" aria-label="Permalink to &quot;1.认识微服务&quot;">​</a></h2><p>认识微服务</p><h2 id="_1-1-单体架构" tabindex="-1">1.1.单体架构 <a class="header-anchor" href="#_1-1-单体架构" aria-label="Permalink to &quot;1.1.单体架构&quot;">​</a></h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><p><img src="'+o+'" alt="image-20210713202807818"></p><p>单体架构的优缺点如下：</p><p><strong>优点：</strong></p><ul><li>架构简单</li><li>部署成本低</li></ul><p><strong>缺点：</strong></p><ul><li>耦合度高（维护困难、升级困难）</li></ul><h2 id="_1-2-分布式架构" tabindex="-1">1.2.分布式架构 <a class="header-anchor" href="#_1-2-分布式架构" aria-label="Permalink to &quot;1.2.分布式架构&quot;">​</a></h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p><p><img src="'+l+'" alt="image-20210713203124797"></p><p>分布式架构的优缺点：</p><p><strong>优点：</strong></p><ul><li>降低服务耦合</li><li>有利于服务升级和拓展</li></ul><p><strong>缺点：</strong></p><ul><li>服务调用关系错综复杂</li></ul><p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p>人们需要制定一套行之有效的标准来约束分布式架构。</p><h2 id="_1-3-微服务" tabindex="-1">1.3.微服务 <a class="header-anchor" href="#_1-3-微服务" aria-label="Permalink to &quot;1.3.微服务&quot;">​</a></h2><p>微服务的架构特征：</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li><li>自治：团队独立、技术独立、数据独立，独立部署和交付</li><li>面向服务：服务提供统一标准的接口，与语言和技术无关</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><p><img src="'+r+'" alt="image-20210713203753373"></p><p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><p>因此，可以认为<strong>微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p><p>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</p><p>其中在Java领域最引人注目的就是SpringCloud提供的方案了。</p><h2 id="_1-4-springcloud" tabindex="-1">1.4.SpringCloud <a class="header-anchor" href="#_1-4-springcloud" aria-label="Permalink to &quot;1.4.SpringCloud&quot;">​</a></h2><p>SpringCloud是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82" target="_blank" rel="noreferrer">https://spring.io/projects/spring-cloud。open in new window</a></p><p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="'+c+'" alt="image-20210713204155887"></p><p>另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：</p><p><img src="'+d+'" alt="image-20210713205003790"></p><p>我们课堂学习的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。</p><h2 id="_1-5-总结" tabindex="-1">1.5.总结 <a class="header-anchor" href="#_1-5-总结" aria-label="Permalink to &quot;1.5.总结&quot;">​</a></h2><ul><li><p>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</p></li><li><p>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</p></li><li><p>微服务：一种良好的分布式架构方案</p><p>①优点：拆分粒度更小、服务更独立、耦合度更低</p><p>②缺点：架构非常复杂，运维、监控、部署难度提高</p></li><li><p>SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</p></li></ul><h2 id="_2-服务拆分和远程调用" tabindex="-1">2.服务拆分和远程调用 <a class="header-anchor" href="#_2-服务拆分和远程调用" aria-label="Permalink to &quot;2.服务拆分和远程调用&quot;">​</a></h2><p>任何分布式架构都离不开服务的拆分，微服务也是一样。</p><h3 id="_2-1-服务拆分-目标1" tabindex="-1">2.1 服务拆分 目标1 <a class="header-anchor" href="#_2-1-服务拆分-目标1" aria-label="Permalink to &quot;2.1 服务拆分 目标1&quot;">​</a></h3><p>服务拆分</p><p><strong>服务拆分原则</strong></p><p>这里我总结了微服务拆分时的几个原则：</p><ul><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li></ul><p><img src="'+a+'" alt="image-20210713210800950"></p><h3 id="_2-2-服务拆分示例" tabindex="-1">2.2.服务拆分示例 <a class="header-anchor" href="#_2-2-服务拆分示例" aria-label="Permalink to &quot;2.2.服务拆分示例&quot;">​</a></h3><p>以课前资料中的微服务cloud-demo为例，其结构如下：</p><p><img src="'+g+'" alt="image-20210713211009593"></p><p>cloud-demo：父工程，管理依赖</p><ul><li>order-service：订单微服务，负责订单相关业务</li><li>user-service：用户微服务，负责用户相关业务</li></ul><p>要求：</p><ul><li>订单微服务和用户微服务都必须有各自的数据库，相互独立</li><li>订单服务和用户服务都对外暴露Restful的接口</li><li>订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库</li></ul><p><strong>服务拆分示例代码操作</strong></p><h5 id="_1️⃣-导入sql语句" tabindex="-1">1️⃣ 导入Sql语句 <a class="header-anchor" href="#_1️⃣-导入sql语句" aria-label="Permalink to &quot;1️⃣ 导入Sql语句&quot;">​</a></h5><p>首先，将课前资料提供的<code>cloud-order.sql</code>和<code>cloud-user.sql</code>导入到mysql中：</p><p><img src="'+u+'" alt="image-20210713211417049"></p><p>cloud-user表中初始数据如下：</p><p><img src="'+m+'" alt="image-20210713211550169"></p><p>cloud-order表中初始数据如下：</p><p><img src="'+h+'" alt="image-20210713211657319"></p><p>cloud-order表中持有cloud-user表中的id字段。</p><h5 id="_2️⃣-导入demo工程" tabindex="-1">2️⃣ 导入demo工程 <a class="header-anchor" href="#_2️⃣-导入demo工程" aria-label="Permalink to &quot;2️⃣ 导入demo工程&quot;">​</a></h5><p>用IDEA导入课前资料提供的Demo：</p><p><img src="'+b+'" alt="image-20210713211814094"></p><p>项目结构如下：</p><p><img src="'+_+'" alt="image-20210713212656887"></p><p>导入后，会在IDEA右下角出现弹窗：</p><p><img src="'+v+'" alt="image-20210713212349272"></p><p>点击弹窗，然后按下图选择：</p><p><img src="'+k+'" alt="image-20210713212336185"></p><p>会出现这样的菜单：</p><p><img src="'+q+'" alt="image-20210713212513324"></p><p>配置下项目使用的JDK：</p><p><img src="'+f+'" alt="image-20210713220736408"></p><h3 id="_2-2-远程调用-目标2" tabindex="-1">2.2 远程调用 目标2 <a class="header-anchor" href="#_2-2-远程调用-目标2" aria-label="Permalink to &quot;2.2 远程调用 目标2&quot;">​</a></h3><p>远程调用</p><p>案例需求</p><p>修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。</p><p><img src="'+C+'" alt="image-20210713213312278"></p><p>因此，我们需要在order-service中 向user-service发起一个http的请求，调用<a href="http://localhost:8081/user/%7BuserId%7D%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E3%80%82" target="_blank" rel="noreferrer">http://localhost:8081/user/{userId}这个接口。open in new window</a></p><p>大概的步骤是这样的：</p><ul><li>注册一个RestTemplate的实例到Spring容器</li><li>修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User</li><li>将查询的User填充到Order对象，一起返回</li></ul><blockquote><p>RestTemplate封装了Http请求</p></blockquote><p>在order-service服务中，有一个根据id查询订单的接口：</p><p><img src="'+y+'" alt="image-20210713212749575"></p><p>根据id查询订单，返回值是Order对象，如图：</p><p><img src="'+B+'" alt="image-20210713212901725"></p><p>其中的user为null</p><p>在user-service中有一个根据id查询用户的接口：</p><p><img src="'+P+'" alt="image-20210713213146089"></p><p>查询的结果如图：</p><p><img src="'+x+`" alt="image-20210713213213075"></p><h3 id="_2-3-2-注册resttemplate" tabindex="-1">2.3.2.注册RestTemplate <a class="header-anchor" href="#_2-3-2-注册resttemplate" aria-label="Permalink to &quot;2.3.2.注册RestTemplate&quot;">​</a></h3><p>首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>package cn.itcast.order;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import org.mybatis.spring.annotation.MapperScan;</span></span>
<span class="line"><span>import org.springframework.boot.SpringApplication;</span></span>
<span class="line"><span>import org.springframework.boot.autoconfigure.SpringBootApplication;</span></span>
<span class="line"><span>import org.springframework.context.annotation.Bean;</span></span>
<span class="line"><span>import org.springframework.web.client.RestTemplate;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span></span>
<span class="line"><span>@SpringBootApplication</span></span>
<span class="line"><span>public class OrderApplication {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>        SpringApplication.run(OrderApplication.class, args);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Bean</span></span>
<span class="line"><span>    public RestTemplate restTemplate() {</span></span>
<span class="line"><span>        return new RestTemplate();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="_2-3-3-实现远程调用" tabindex="-1">2.3.3.实现远程调用 <a class="header-anchor" href="#_2-3-3-实现远程调用" aria-label="Permalink to &quot;2.3.3.实现远程调用&quot;">​</a></h3><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法：</p><p><img src="`+S+'" alt="image-20210713213959569"></p><p>课堂作业</p><p>🚩 1. 导入课程实例，在浏览器发起请求，正常输出json数据</p><h3 id="_2-3-提供者与消费者" tabindex="-1">2.3 提供者与消费者 <a class="header-anchor" href="#_2-3-提供者与消费者" aria-label="Permalink to &quot;2.3 提供者与消费者&quot;">​</a></h3><p>提供者与消费者</p><p>结合下图，思考上述代码中，在服务调用关系中，各个模块扮演的角色 <img src="'+a+'" alt=""></p><p><strong>在服务调用关系中，会有两个不同的角色：</strong></p><p><strong>服务提供者</strong>：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</p><p><strong>服务消费者</strong>：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p><p><img src="'+R+'" alt="image-20210713214404481"></p><p>但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。</p><p>如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？</p><ul><li>对于A调用B的业务而言：A是服务消费者，B是服务提供者</li><li>对于B调用C的业务而言：B是服务消费者，C是服务提供者</li></ul><p>因此，服务B既可以是服务提供者，也可以是服务消费者。</p><p>课堂作业</p><p>🚩 1. 说出消费者和提供者的特点？并根据其特性，举出生活中的列子</p><h2 id="_3-eureka注册中心" tabindex="-1">3.Eureka注册中心 <a class="header-anchor" href="#_3-eureka注册中心" aria-label="Permalink to &quot;3.Eureka注册中心&quot;">​</a></h2><h3 id="_3-1-eureka的结构和作用" tabindex="-1">3.1.Eureka的结构和作用 <a class="header-anchor" href="#_3-1-eureka的结构和作用" aria-label="Permalink to &quot;3.1.Eureka的结构和作用&quot;">​</a></h3><p>前言</p><p>假如我们的服务提供者user-service部署了多个实例，如图：</p><p><img src="'+A+'" alt="image-20210713214925388"></p><p>大家思考几个问题：</p><ul><li>order-service在发起远程调用的时候，该如何得知<strong>user-service实例的ip地址和端口</strong>？</li><li>有多个user-service实例地址，order-service调用时该<strong>如何选择</strong>？</li><li>order-service如何得知某个user-service<strong>实例是否依然健康，是不是已经宕机</strong>？</li></ul><p>这些问题都需要利用<strong>SpringCloud中的注册中心</strong>来解决，其中最广为人知的注册中心就是Eureka，其结构如下：</p><p><img src="'+I+'" alt="image-20210713220104956"></p><blockquote><p>Eureak 是<strong>Netflix 开源微服务框架</strong>中一系列项目中的一个。Spring Cloud对其进行了<strong>二次封装</strong>,形成了Spring Cloud Netflix 子项目,<strong>但未对Netflix微服务实现原理进行更改,只是进行了Spring Boot化</strong>,使开发者更容易使用和整合。</p></blockquote><p>学习Eureka之前，先思考下述问题 👇👇</p><p><strong>问题1：order-service如何得知user-service实例地址？</strong></p><p>获取地址信息的流程如下（参考上图☝️）：</p><ul><li>user-service 服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册</li><li>eureka-server 保存服务名称到服务实例地址列表的映射关系</li><li>order-service 根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li></ul><p><strong>问题2：order-service如何从多个user-service实例中选择具体的实例？</strong></p><ul><li>order-service 从 <strong>实例列表</strong> 中利用负载均衡算法 选中一个实例地址📃</li><li>向<strong>该实例地址</strong>发起远程调用</li></ul><p><strong>问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</strong></p><blockquote><p>对应上图的橙色箭头</p></blockquote><ul><li>user-service 会每隔一段时间（默认30秒 ）向eureka-server发起请求，报告自己状态，称为心跳 💓</li><li>当<strong>超过一定时间没有发送心跳时</strong>💔，eureka-server会认为微服务实例故障💥，将该实例从服务列表中<strong>剔除</strong></li><li><strong>order-service拉取服务时</strong>，就能将故障实例排除了</li></ul><blockquote><p>注意：一个微服务，既可以是服务提供者 🏨，又可以是服务消费者💂♂️，因此eureka将服务注册、服务发现等功能统一封装到了<strong>eureka-client端</strong></p></blockquote><p>因此，接下来我们动手实践的步骤包括：</p><p><img src="'+N+'" alt="image-20210713220509769"></p><h3 id="_3-2-搭建注册中心-🔧" tabindex="-1">3.2.搭建注册中心 🔧 <a class="header-anchor" href="#_3-2-搭建注册中心-🔧" aria-label="Permalink to &quot;3.2.搭建注册中心 🔧&quot;">​</a></h3><p>首先大家注册中心服务端：eureka-server，这必须是一个独立 的微服务</p><p>搭建eureka-server注册中心</p><p>步骤</p><ol><li>创建eureka-server服务</li><li>引入eureka依赖</li><li>编写启动类</li><li>编写配置文件</li><li>启动服务</li></ol><p><strong>代码操作</strong></p><h4 id="_3-2-1-创建eureka-server服务" tabindex="-1">3.2.1.创建eureka-server服务 <a class="header-anchor" href="#_3-2-1-创建eureka-server服务" aria-label="Permalink to &quot;3.2.1.创建eureka-server服务&quot;">​</a></h4><p>在<code>cloud-demo父工程</code>下，创建一个<code>子模块</code>：</p><p><img src="'+E+'" alt="image-20210713220605881"></p><p>填写模块信息：</p><p><img src="'+D+'" alt="image-20210713220857396"></p><p>然后填写服务信息(注意：在父工程cloud-demo下 )：</p><p><img src="'+T+`" alt="image-20210713221339022"></p><h4 id="_3-2-2-引入eureka依赖" tabindex="-1">3.2.2.引入eureka依赖 <a class="header-anchor" href="#_3-2-2-引入eureka依赖" aria-label="Permalink to &quot;3.2.2.引入eureka依赖&quot;">​</a></h4><p>引入SpringCloud为eureka提供的starter依赖：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre></div><blockquote><p>导入后，检查idea的右侧maven中的denpendies中是否存在依赖</p></blockquote><h4 id="_3-2-3-编写启动类" tabindex="-1">3.2.3.编写启动类 <a class="header-anchor" href="#_3-2-3-编写启动类" aria-label="Permalink to &quot;3.2.3.编写启动类&quot;">​</a></h4><p>给eureka-server服务<strong>编写一个启动类</strong>，一定要添加一个<code>@EnableEurekaServer</code>注解，开启eureka的注册中心功能：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>package cn.itcast.eureka;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>@SpringBootApplication</span></span>
<span class="line"><span>// 开启eureka的注册中心功能</span></span>
<span class="line"><span>@EnableEurekaServer</span></span>
<span class="line"><span>public class EurekaApplication {</span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>        SpringApplication.run(EurekaApplication.class, args);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="_3-2-4-编写配置文件" tabindex="-1">3.2.4.编写配置文件 <a class="header-anchor" href="#_3-2-4-编写配置文件" aria-label="Permalink to &quot;3.2.4.编写配置文件&quot;">​</a></h4><p>编写一个application.yml文件，内容如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>server:</span></span>
<span class="line"><span>  port: 10086</span></span>
<span class="line"><span>spring:</span></span>
<span class="line"><span>  application:</span></span>
<span class="line"><span>    name: eureka-server</span></span>
<span class="line"><span>eureka:</span></span>
<span class="line"><span>  client:</span></span>
<span class="line"><span>    service-url: </span></span>
<span class="line"><span>      defaultZone: http://127.0.0.1:10086/eureka</span></span></code></pre></div><blockquote><p>注意：写成default-zone不可以，eureka并不认识这个</p><p>defaultZone 代表的就是 eureka server ( 服务发现和注册中心)的地址</p><p>作为注册中心为什么要注册？因为未来会有多个eureka组成集群，需要互相注册</p></blockquote><h3 id="_3-3-服务注册-🔖" tabindex="-1">3.3.服务注册 🔖 <a class="header-anchor" href="#_3-3-服务注册-🔖" aria-label="Permalink to &quot;3.3.服务注册 🔖&quot;">​</a></h3><p>服务注册</p><p><strong>下面，我们将user-service注册到eureka-server中去。</strong> 🎯</p><p><img src="`+s+`" alt="服务注册"></p><p>服务注册</p><p><strong>代码操作</strong></p><h4 id="_1-引入依赖" tabindex="-1">1）引入依赖 <a class="header-anchor" href="#_1-引入依赖" aria-label="Permalink to &quot;1）引入依赖&quot;">​</a></h4><p>在<code>user-service的pom文件中</code>，引入下面的<code>eureka-client依赖</code>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre></div><h4 id="_2-配置文件" tabindex="-1">2）配置文件 <a class="header-anchor" href="#_2-配置文件" aria-label="Permalink to &quot;2）配置文件&quot;">​</a></h4><p>在<code>user-service</code>中，修改<code>application.yml</code>文件，添加服务名称、eureka地址：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>spring:</span></span>
<span class="line"><span>  application:</span></span>
<span class="line"><span>    name: userservice</span></span>
<span class="line"><span>eureka:</span></span>
<span class="line"><span>  client:</span></span>
<span class="line"><span>    service-url:</span></span>
<span class="line"><span>      defaultZone: http://127.0.0.1:10086/eureka</span></span></code></pre></div><h4 id="_3-启动多个user-service实例" tabindex="-1">3）启动多个user-service实例 <a class="header-anchor" href="#_3-启动多个user-service实例" aria-label="Permalink to &quot;3）启动多个user-service实例&quot;">​</a></h4><p>为了演示一个服务有多个实例的场景 多例，我们添加一个SpringBoot的启动配置，再启动一个user-service。</p><p>首先，复制原来的user-service启动配置：</p><p><img src="`+L+'" alt="image-20210713222656562"></p><p>然后，在弹出的窗口中，填写信息（新的应用名字、新的端口 ）：</p><p><img src="'+w+'" alt="image-20210713222757702"></p><p>现在，SpringBoot窗口会出现两个user-service启动配置：</p><p><img src="'+O+'" alt="image-20210713222841951"></p><p><strong>不过，第一个是8081端口，第二个是8082端口。</strong></p><p>启动两个user-service实例：</p><p><img src="'+H+'" alt="image-20210713223041491"></p><p>查看eureka-server管理页面：</p><p><img src="'+Z+`" alt="image-20210713223150650"></p><blockquote><p>因为yml中配置的应用名字一样，因此同一个服务名字下，有多个实例</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>spring:</span></span>
<span class="line"><span>  application:</span></span>
<span class="line"><span>    name: userservice</span></span></code></pre></div><h3 id="_3-4-服务发现🔍" tabindex="-1">3.4.服务发现🔍 <a class="header-anchor" href="#_3-4-服务发现🔍" aria-label="Permalink to &quot;3.4.服务发现🔍&quot;">​</a></h3><p>服务发现</p><p>相关信息</p><p>下面，我们将<code>order-service</code>的逻辑修改：向eureka-server拉取<code>user-service的信息</code>，实现服务发现🔍。</p><p><img src="`+s+`" alt=""></p><p><strong>代码操作</strong></p><h4 id="_1-引入依赖-1" tabindex="-1">1）引入依赖 <a class="header-anchor" href="#_1-引入依赖-1" aria-label="Permalink to &quot;1）引入依赖&quot;">​</a></h4><p><strong>服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。</strong></p><p>在<strong>order-service的pom文件中</strong>，引入下面的<strong>eureka-client依赖</strong>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre></div><h4 id="_2-配置文件-1" tabindex="-1">2）配置文件 <a class="header-anchor" href="#_2-配置文件-1" aria-label="Permalink to &quot;2）配置文件&quot;">​</a></h4><p>服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息：</p><p>在order-service中，修改application.yml文件，添加服务名称、eureka地址：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>spring:</span></span>
<span class="line"><span>  application:</span></span>
<span class="line"><span>    name: orderservice</span></span>
<span class="line"><span>eureka:</span></span>
<span class="line"><span>  client:</span></span>
<span class="line"><span>    service-url:</span></span>
<span class="line"><span>      defaultZone: http://127.0.0.1:10086/eureka</span></span></code></pre></div><h4 id="_3-服务拉取和负载均衡" tabindex="-1">3）服务拉取和负载均衡 <a class="header-anchor" href="#_3-服务拉取和负载均衡" aria-label="Permalink to &quot;3）服务拉取和负载均衡&quot;">​</a></h4><p>最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现<strong>负载均衡</strong>。</p><p><strong>不过这些动作不用我们去做，只需要添加一些注解即可。</strong></p><p>在<code>order-service</code>的<code>OrderApplication</code>中，给<code>RestTemplate这个Bean</code>添加一个<code>@LoadBalanced</code>注解：</p><p><img src="`+K+'" alt="image-20210713224049419"></p><p>修改 <code>order-service</code>服务中的<code>cn.itcast.order.service</code>包下的<code>OrderService类</code>中的<code>queryOrderById</code>方法。修改<code>访问的url路径，用服务名代替ip、端口</code>：</p><p><img src="'+U+'" alt="image-20210713224245731"></p><p>spring会自动帮助我们从<strong>eureka-server端</strong>，<strong>根据userservice这个服务名称</strong>，获取<strong>实例列表</strong>，而后完成负载均衡。</p><blockquote><p>负载均衡：其基本概念是为了减轻某个或某些实体的负载，将任务通过某种策略分配到多个实体上去，实现负载在不同实体间的平衡。</p></blockquote><h2 id="_4-ribbon负载均衡" tabindex="-1">4.Ribbon负载均衡 <a class="header-anchor" href="#_4-ribbon负载均衡" aria-label="Permalink to &quot;4.Ribbon负载均衡&quot;">​</a></h2><h3 id="_4-1-负载均衡原理和源码" tabindex="-1">4.1.负载均衡原理和源码 <a class="header-anchor" href="#_4-1-负载均衡原理和源码" aria-label="Permalink to &quot;4.1.负载均衡原理和源码&quot;">​</a></h3><p>Ribbon[ˈrɪbən]负载均衡</p><p>注意</p><p>上一节中，我们添加了<code>@LoadBalanced注解</code>，即可实现<code>负载均衡功能</code>，这是什么原理呢？</p><p>SpringCloud底层其实是利用了一个名为<strong>Ribbon的组件</strong>，来实现<strong>负载均衡</strong>功能的。</p><p><img src="'+j+'" alt="image-20210713224517686"></p><p>那么我们发出的请求明明是<code>http://userservice/user/1</code>，怎么变成了<code>http://localhost:8081的呢？</code></p><p>欲知详情如何，请查看<code>源码跟踪求解</code> 👉</p><h3 id="_4-2-源码跟踪" tabindex="-1">4.2.源码跟踪 <a class="header-anchor" href="#_4-2-源码跟踪" aria-label="Permalink to &quot;4.2.源码跟踪&quot;">​</a></h3><p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p><p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p><p>我们进行源码跟踪：</p><h4 id="_1-loadbalancerinterceptor" tabindex="-1">1）LoadBalancerInterceptor <a class="header-anchor" href="#_1-loadbalancerinterceptor" aria-label="Permalink to &quot;1）LoadBalancerInterceptor&quot;">​</a></h4><p><img src="'+W+'" alt="1525620483637"></p><p>1525620483637</p><p>可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：获取请求uri，本例中就是 <a href="http://user-service/user/8" target="_blank" rel="noreferrer">http://user-service/user/8open in new window</a></li><li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id，<code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求。</li></ul><p>这里的<code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型，我们继续跟入。</p><h4 id="_2-loadbalancerclient" tabindex="-1">2）LoadBalancerClient <a class="header-anchor" href="#_2-loadbalancerclient" aria-label="Permalink to &quot;2）LoadBalancerClient&quot;">​</a></h4><p>继续跟入execute方法：</p><p><img src="'+F+'" alt="1525620787090"></p><p>1525620787090</p><p>代码是这样的：</p><ul><li>getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。</li><li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</li></ul><p>放行后，再次访问并跟踪，发现获取的是8081：</p><p><img src="'+e+'" alt="1525620835911"></p><p>1525620835911</p><p>果然实现了负载均衡。</p><h4 id="_3-负载均衡策略irule" tabindex="-1">3）负载均衡策略IRule <a class="header-anchor" href="#_3-负载均衡策略irule" aria-label="Permalink to &quot;3）负载均衡策略IRule&quot;">​</a></h4><p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡:</p><p><img src="'+e+'" alt="1525620835911"></p><p>1525620835911</p><p>我们继续跟入：</p><p><img src="'+M+'" alt="1544361421671"></p><p>1544361421671</p><p>继续跟踪源码chooseServer方法，发现这么一段代码：</p><p><img src="'+V+'" alt="1525622652849"></p><p>1525622652849</p><p>我们看看这个rule是谁：（ctrl+H快捷键）</p><p><img src="'+X+'" alt="1525622699666"></p><p>1525622699666</p><p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p><p><img src="'+Y+'" alt="1525622754316"></p><p>1525622754316</p><p>这不就是轮询的意思嘛。</p><p>到这里，整个负载均衡的流程我们就清楚了。</p><p>总结</p><p><code>SpringCloudRibbon</code>[ˈrɪbən]的底层采用了一个<strong>拦截器</strong>，拦截了<strong>RestTemplate</strong>发出的请求，对地址做了修改。用一幅图来总结一下：</p><p><img src="'+J+'" alt="image-20210713224724673"></p><p>基本流程如下：</p><ul><li>拦截我们的RestTemplate请求<code>http://userservice/user/1</code></li><li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li><li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li><li>eureka返回列表，localhost:8081、localhost:8082</li><li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li><li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<code>http://localhost:8081/user/1</code>，发起真实请求</li></ul><h3 id="_4-2-负载均衡策略和加载方式" tabindex="-1">4.2.负载均衡策略和加载方式 <a class="header-anchor" href="#_4-2-负载均衡策略和加载方式" aria-label="Permalink to &quot;4.2.负载均衡策略和加载方式&quot;">​</a></h3><p>负载均衡策略</p><h4 id="_4-3-1-负载均衡策略" tabindex="-1">4.3.1.负载均衡策略 <a class="header-anchor" href="#_4-3-1-负载均衡策略" aria-label="Permalink to &quot;4.3.1.负载均衡策略&quot;">​</a></h4><p><strong>负载均衡的规则都定义在IRule接口</strong>中，而IRule有很多不同的实现类：</p><p><img src="'+Q+`" alt="image-20210713225653000"></p><p>不同规则的含义如下：</p><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略： （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<code>&lt;clientName&gt;.&lt;clientConfigNameSpace&gt;</code>.ActiveConnectionsLimit属性进行配置。</td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong>👈</td><td>以<strong>区域可用的服务器</strong>为基础进行服务器的选择。使用<strong>Zone对服务器进行分类</strong>，这个Zone可以理解为一个机房、一个机架等。而后再对<strong>Zone内</strong>的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><p>默认的实现就是ZoneAvoidanceRule，是一种轮询方案</p><h4 id="自定义负载均衡策略" tabindex="-1">自定义负载均衡策略 <a class="header-anchor" href="#自定义负载均衡策略" aria-label="Permalink to &quot;自定义负载均衡策略&quot;">​</a></h4><p><strong>通过定义IRule实现可以修改负载均衡规则</strong>，有两种方式：</p><ol><li>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>@Bean</span></span>
<span class="line"><span>public IRule randomRule(){</span></span>
<span class="line"><span>    return new RandomRule();</span></span>
<span class="line"><span>}</span></span></code></pre></div><blockquote><p>这种配置方式，作用于全局</p></blockquote><ol start="2"><li>配置文件方式：在<strong>order-service的application.yml文件中</strong>，添加新的配置也可以修改规则：</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务</span></span>
<span class="line"><span>  ribbon:</span></span>
<span class="line"><span>    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则</span></span></code></pre></div><blockquote><p>这种配置方式作用与某一个服务，（记得注释全局的配置）</p></blockquote><blockquote><p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p></blockquote><h4 id="饥饿加载-👇" tabindex="-1">饥饿加载 👇 <a class="header-anchor" href="#饥饿加载-👇" aria-label="Permalink to &quot;饥饿加载 👇&quot;">​</a></h4><p><strong>Ribbon默认是采用懒加载</strong>，即<strong>第一次访问时才会去创建LoadBalanceClient</strong>，请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载空间换时间：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span># 定格写</span></span>
<span class="line"><span>ribbon:</span></span>
<span class="line"><span>  eager-load:</span></span>
<span class="line"><span>    enabled: true</span></span>
<span class="line"><span>    clients: userservice</span></span>
<span class="line"><span>    # 要指定对谁进行饥饿加载</span></span></code></pre></div><p>课堂作业</p><p>🚩</p><ol><li>负载均衡的策略默认是什么模式？有何特点？</li><li>如何自定义负载均衡策略？</li><li>Ribbon负载均衡策略加载默认是什么方式？有和缺点？如何改善？</li></ol><h2 id="_5-nacos注册中心-🍐❤️" tabindex="-1">5.Nacos注册中心 🍐❤️ <a class="header-anchor" href="#_5-nacos注册中心-🍐❤️" aria-label="Permalink to &quot;5.Nacos注册中心 🍐❤️&quot;">​</a></h2><p>国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。</p><h3 id="_5-1-认识和安装nacos" tabindex="-1">5.1.认识和安装Nacos <a class="header-anchor" href="#_5-1-认识和安装nacos" aria-label="Permalink to &quot;5.1.认识和安装Nacos&quot;">​</a></h3><h3 id="_5-2-服务注册到nacos" tabindex="-1">5.2.服务注册到nacos <a class="header-anchor" href="#_5-2-服务注册到nacos" aria-label="Permalink to &quot;5.2.服务注册到nacos&quot;">​</a></h3><p>服务注册到nacos</p><p>Nacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。</p><p>主要差异在于：</p><ul><li>依赖不同</li><li>服务地址不同</li></ul><p><strong>代码操作</strong></p><h4 id="_1-引入依赖-2" tabindex="-1">1）引入依赖 <a class="header-anchor" href="#_1-引入依赖-2" aria-label="Permalink to &quot;1）引入依赖&quot;">​</a></h4><p>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span></span>
<span class="line"><span>    &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;</span></span>
<span class="line"><span>    &lt;type&gt;pom&lt;/type&gt;</span></span>
<span class="line"><span>    &lt;scope&gt;import&lt;/scope&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre></div><p>然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre></div><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的依赖。</p></blockquote><h4 id="_2-配置nacos地址" tabindex="-1">2）配置nacos地址 <a class="header-anchor" href="#_2-配置nacos地址" aria-label="Permalink to &quot;2）配置nacos地址&quot;">​</a></h4><p>在user-service和order-service的application.yml中添加nacos地址：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>spring:</span></span>
<span class="line"><span>  cloud:</span></span>
<span class="line"><span>    nacos:</span></span>
<span class="line"><span>      server-addr: localhost:8848</span></span></code></pre></div><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的地址</p></blockquote><h4 id="_3-重启" tabindex="-1">3）重启 <a class="header-anchor" href="#_3-重启" aria-label="Permalink to &quot;3）重启&quot;">​</a></h4><p>重启微服务后，登录nacos管理页面，可以看到微服务信息：</p><p><img src="`+z+'" alt="image-20210713231439607"></p><h3 id="_5-3-服务分级存储模型" tabindex="-1">5.3.服务分级存储模型 <a class="header-anchor" href="#_5-3-服务分级存储模型" aria-label="Permalink to &quot;5.3.服务分级存储模型&quot;">​</a></h3><p>服务分级存储模型</p><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p><blockquote><p>容灾系统是指在相隔较远的异地，建立两套或多套功能相同的IT系统，互相之间可以进行健康状态监视和功能切换，当一处系统因意外（如火灾、地震等）停止工作时，整个应用系统可以切换到另一处，使得该系统功能可以继续正常工作。容灾技术是系统的高可用性技术</p></blockquote><p>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p><p><img src="'+$+'" alt="image-20210713232522531"></p><p><strong>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群</strong>。例如：</p><p><img src="'+G+`" alt="image-20210713232658928"></p><p>杭州机房内的order-service应该优先访问同机房的user-service。 👈</p><p>修改user-service的application.yml文件，添加集群配置：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>spring:</span></span>
<span class="line"><span>  cloud:</span></span>
<span class="line"><span>    nacos:</span></span>
<span class="line"><span>      server-addr: localhost:8848</span></span>
<span class="line"><span>      discovery:</span></span>
<span class="line"><span>        cluster-name: HZ # 集群名称</span></span></code></pre></div><p>重启两个user-service实例后，我们可以在nacos控制台看到下面结果：</p><p><img src="`+aa+'" alt="image-20210713232916215"></p><p>我们再次复制一个user-service启动配置，添加属性：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH</span></span></code></pre></div><p>配置如图所示：</p><p><img src="'+sa+'" alt="image-20210713233528982"></p><p>启动UserApplication3后再次查看nacos控制台：</p><p><img src="'+ea+`" alt="image-20210713233727923"></p><p>默认的<code>ZoneAvoidanceRule</code>并<strong>不能实现根据同集群优先来实现负载均衡</strong>。</p><p>因此Nacos中提供了一个<code>NacosRule</code>的实现，可以<strong>优先从同集群中挑选实例。</strong> 👈</p><h5 id="_1️⃣-1-给order-service配置集群信息" tabindex="-1">1️⃣ 1）给order-service配置集群信息 <a class="header-anchor" href="#_1️⃣-1-给order-service配置集群信息" aria-label="Permalink to &quot;1️⃣ 1）给order-service配置集群信息&quot;">​</a></h5><p>修改order-service的application.yml文件，添加集群配置：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>spring:</span></span>
<span class="line"><span>  cloud:</span></span>
<span class="line"><span>    nacos:</span></span>
<span class="line"><span>      server-addr: localhost:8848</span></span>
<span class="line"><span>      discovery:</span></span>
<span class="line"><span>        cluster-name: HZ # 集群名称</span></span></code></pre></div><h5 id="_2️⃣-2-修改负载均衡规则" tabindex="-1">2️⃣ 2）修改负载均衡规则 <a class="header-anchor" href="#_2️⃣-2-修改负载均衡规则" aria-label="Permalink to &quot;2️⃣ 2）修改负载均衡规则&quot;">​</a></h5><p>修改order-service的application.yml文件，修改负载均衡规则：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>userservice:</span></span>
<span class="line"><span>  ribbon:</span></span>
<span class="line"><span>    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则</span></span></code></pre></div><p>课堂作业</p><p>🚩 1. 为什么要学习服务分级存储模型？</p><h3 id="_5-4-权重配置和环境隔离" tabindex="-1">5.4.权重配置和环境隔离 <a class="header-anchor" href="#_5-4-权重配置和环境隔离" aria-label="Permalink to &quot;5.4.权重配置和环境隔离&quot;">​</a></h3><p>权重配置和环境隔离</p><p>权重配置</p><p>实际部署中会出现这样的场景：</p><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p><p>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。</p><p>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</p><p><img src="`+pa+'" alt="image-20210713235133225"></p><p>在弹出的编辑窗口，修改权重：</p><p><img src="'+na+'" alt="image-20210713235235219"></p><blockquote><p>实际开发中，如果要升级，但是往常要停机，但是现在可以设置权重为0，然后升级</p></blockquote><blockquote><p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</p></blockquote><h3 id="_5-5-环境隔离" tabindex="-1">5.5.环境隔离 <a class="header-anchor" href="#_5-5-环境隔离" aria-label="Permalink to &quot;5.5.环境隔离&quot;">​</a></h3><p>环境隔离</p><p>Nacos提供了namespace来实现环境隔离功能。</p><ul><li>nacos中可以有多个namespace</li><li>namespace下可以有group、service等</li><li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li></ul><p><img src="'+ia+'" alt="image-20210714000101516"></p><h4 id="_5-5-1-创建namespace" tabindex="-1">5.5.1.创建namespace <a class="header-anchor" href="#_5-5-1-创建namespace" aria-label="Permalink to &quot;5.5.1.创建namespace&quot;">​</a></h4><p>默认情况下，所有<strong>service、data、group</strong>都在同一个namespace，名为public：</p><p><img src="'+ta+'" alt="image-20210714000414781"></p><p>我们可以点击页面新增按钮，添加一个namespace：</p><p><img src="'+oa+'" alt="image-20210714000440143"></p><p>然后，填写表单：</p><p><img src="'+la+'" alt="image-20210714000505928"></p><p>就能在页面看到一个新的namespace：</p><p><img src="'+ra+`" alt="image-20210714000522913"></p><h4 id="_5-5-2-给微服务配置namespace" tabindex="-1">5.5.2.给微服务配置namespace <a class="header-anchor" href="#_5-5-2-给微服务配置namespace" aria-label="Permalink to &quot;5.5.2.给微服务配置namespace&quot;">​</a></h4><p><strong>给微服务配置namespace只能通过修改配置</strong>来实现。</p><p>例如，修改order-service的application.yml文件：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>spring:</span></span>
<span class="line"><span>  cloud:</span></span>
<span class="line"><span>    nacos:</span></span>
<span class="line"><span>      server-addr: localhost:8848</span></span>
<span class="line"><span>      discovery:</span></span>
<span class="line"><span>        cluster-name: HZ</span></span>
<span class="line"><span>        namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间，填ID</span></span></code></pre></div><p>重启order-service后，访问控制台，可以看到下面的结果：</p><p><img src="`+ca+'" alt="image-20210714000830703"></p><p><img src="'+da+'" alt="image-20210714000837140"></p><p>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：</p><p><img src="'+ga+`" alt="image-20210714000941256"></p><h3 id="_5-5-nacos与eureka的区别-❤️-🍐" tabindex="-1">5.5.Nacos与Eureka的区别 ❤️ 🍐 <a class="header-anchor" href="#_5-5-nacos与eureka的区别-❤️-🍐" aria-label="Permalink to &quot;5.5.Nacos与Eureka的区别 ❤️ 🍐&quot;">​</a></h3><p>提示</p><p>Nacos的服务实例分为两种l类型：</p><ul><li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p></li><li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><p>配置一个服务实例为永久实例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>spring:</span></span>
<span class="line"><span>  cloud:</span></span>
<span class="line"><span>    nacos:</span></span>
<span class="line"><span>      discovery:</span></span>
<span class="line"><span>        ephemeral: false # 设置为非临时实例</span></span></code></pre></div><p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p><p><img src="`+ua+'" alt="image-20210714001728017"></p><ul><li><p>Nacos与eureka的共同点</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li><p>Nacos与Eureka的区别</p><ul><li>Nacos支持服务端<code>主动检测</code>提供者状态：<code>临时实例采用心跳模式</code>，<code>非临时实例采用主动检测模式</code></li><li><code>临时</code>实例心跳<code>不正常会被剔除</code>，<code>非临时</code>实例则<code>不会被剔除</code></li><li>Nacos支持<code>服务列表变更的消息推送</code>模式，`服务列表更新更及时，但是耗性能</li><li>Nacos集群<code>默认采用AP方式</code>，当集群中存在非临时实例时，<code>采用CP模式</code>；Eureka采用AP方式</li></ul></li></ul><blockquote><p>CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance），但是CAP 原则指示3个要素最多只能同时实现两点，不可能三者兼顾，</p></blockquote><blockquote><p>AP</p><p>当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。</p><p>结论：违背了一致性C的要求，只满足可用性和分区容错，即AP</p></blockquote><blockquote><p>CP</p><p>当网络分区出现后，为了保证一致性，就必须拒绝请求，否则无法保证一致性。</p><p>结论：违背了可用性A的要求，只满足一致性和分区容错，即CP</p></blockquote>',393),ba=[ha];function _a(va,ka,qa,fa,Ca,ya){return i(),n("div",null,ba)}const xa=p(ma,[["render",_a]]);export{Pa as __pageData,xa as default};

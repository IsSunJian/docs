import{_ as p,c as n,o as t,a4 as e}from"./chunks/framework.-JfgED0h.js";const l="/docs/assets/image-20221130095316032.CaaWdPI_.png",i="/docs/assets/image-20221130104014162.BO3-6yjD.png",o="/docs/assets/image-20220616001159531.CdC8gUiG.png",r="/docs/assets/image-20221130212841973.BpD9U1tN.png",c="/docs/assets/image-20221130220539444.BbZXGER2.png",g="/docs/assets/image-20221130140132209.DpxFW8hT.png",m="/docs/assets/image-20221130140247524.Be4TwFDF.png",d="/docs/assets/image-20221130222907628.Bt18ShoG.png",a="/docs/assets/image-20221130142100703.Be5CwV9A.png",h="/docs/assets/image-20221130142643255.CXICujBm.png",u="/docs/assets/image-20220616094113852.B1mfgnw1.png",_="/docs/assets/image-20221130230134757.t0coQBWN.png",b="/docs/assets/image-20221130143139644.DhCij-An.png",v="/docs/assets/image-20221130174805973.hH0VU4w4.png",q="/docs/assets/image-20220616095633552.BurL86cD.png",k="/docs/assets/image-20220616100211209.CUA01nv5.png",f="/docs/assets/1-1669821012006._IjQSV6F.gif",T="/docs/assets/image-20220616100529868-1669794069698.B91J4kEK.png",S="/docs/assets/image-20221130231857537.BrJtQ9ZV.png",w="/docs/assets/2.D20HydIr.gif",P="/docs/assets/3.OAoDOwVX.gif",M="/docs/assets/image-20221130161346565.DdudLGJC.png",x="/docs/assets/image-20220616102344350.cFCsekFj.png",B="/docs/assets/image-20220616102435856.S8rHr_ON.png",j="/docs/assets/image-20220616102554143.DCWBfgFQ.png",C="/docs/assets/image-20220616103219646.YJpkF11n.png",D="/docs/assets/image-20221130234731629.pnBQvW8K.png",y="/docs/assets/image-20220616103302386.gxioCXx5.png",s="/docs/assets/image-20221201093737128.Bf77yz3E.png",E="/docs/assets/4.CkvHd55G.gif",H="/docs/assets/image-20220616104338612.BKLh8x0m.png",A="/docs/assets/image-20220616104517726.DT7pZdD7.png",I="/docs/assets/image-20221201095621738.BNOHvkGH.png",O="/docs/assets/image-20221201095600057.PtYQa-cZ.png",W="/docs/assets/image-20221201095831320.CNlOWRMP.png",J="/docs/assets/image-20221201100011799.5SEfZ0L1.png",L="/docs/assets/image-20221201100502234.DFydVlDD.png",R="/docs/assets/image-20221201101603397.Dvn92Ky0.png",U="/docs/assets/image-20221201101643427.CK445qgP.png",F="/docs/assets/image-20220616111031057.Dd7FKpsG.png",N="/docs/assets/image-20221201104320521.C516arZc.png",V="/docs/assets/image-20221201104906754.Dr6Szwtw.png",G="/docs/assets/image-20220616111937679.2eQGXS4U.png",K="/docs/assets/image-20220823161727718.Dhp_oLSM.png",Y="/docs/assets/image-20221201105532909.KfiZpB15.png",X="/docs/assets/image-20221201105845872.CNKXvHLx.png",z="/docs/assets/image-20221130184402805.B-iHWc_z.png",Z="/docs/assets/5.Cqd2KzKb.gif",Q="/docs/assets/6.C1f0qMoD.gif",$="/docs/assets/7.qVdm90QR.gif",aa="/docs/assets/image-20221201120514644.C6p_-Dy0.png",sa="/docs/assets/image-20221201113659400.CFe-iwrI.png",pa="/docs/assets/image-20220616115445812.B-jeHGgZ.png",na="/docs/assets/image-20221201115801806.BbADv7mA.png",ta="/docs/assets/image-20221201141929240.C4jonuUJ.png",ea="/docs/assets/image-20221201142501556.BWnH7pws.png",la="/docs/assets/image-20221201135142706.X7TAozuD.png",ia="/docs/assets/image-20220616123806894.B6c1kYjO.png",oa="/docs/assets/image-20221201140140947.BnSfGiUY.png",ra="/docs/assets/image-20220616124015567.DHYbFFgC.png",ca="/docs/assets/image-20220616124348972.CYUKpLEb.png",ga="/docs/assets/image-20221201151340340.B_zmXWMb.png",ma="/docs/assets/image-20221201161957301.CLYoiYXS.png",da="/docs/assets/image-20221201163711835.LFnPoLgi.png",ha="/docs/assets/image-20221201164627403.DcmFqkLn.png",ua="/docs/assets/image-20221201165801341.NoCLX_7c.png",_a="/docs/assets/image-20221201170830837.BkAqRua9.png",ba="/docs/assets/image-20221201171529382.nZJUKDIu.png",va="/docs/assets/image-20221201172210253.BxnHBMCu.png",qa="/docs/assets/image-20221201172914648.Y1CD1-1c.png",ka="/docs/assets/1537786634456-1582625518984.PdsBUt2X.png",fa="/docs/assets/lastUpdated-1582625518983.BD1BjW35.png",Ta="/docs/assets/image-20221214154949482.CJhibRA8.png",Sa="/docs/assets/image-20221214154559817.DzKp9ngE.png",wa="/docs/assets/image-20220617222925923.7ZZUcDjs.png",Pa="/docs/assets/image-20220617222609699.CYtBfcf9.png",Ma="/docs/assets/image-20220617224427947.C98xljLy.png",xa="/docs/assets/image-20220823185227296.C_2W5wDy.png",Ba="/docs/assets/image-20220823191003444.CbaNVMVq.png",ja="/docs/assets/image-20221201184702136.DTd2SN5v.png",Ca="/docs/assets/image-20221201184850248.mYiB1SyD.png",Da="/docs/assets/image-20221201185910596.CSMfpbNF.png",ya="/docs/assets/image-20221201190541295.B3nDd8FS.png",Ea="/docs/assets/image-20221201190825439.DVdWMkMm.png",Ha="/docs/assets/image-20221201191028124.D6E1d0HR.png",Aa="/docs/assets/image-20221201191348924.Dw1vWQvw.png",Ia="/docs/assets/image-20220823195048415.BcOVmj5B.png",Oa="/docs/assets/image-20221201224603497.CNo9d2-G.png",Wa="/docs/assets/image-20220823200024507.BjLfx5Kq.png",Ja="/docs/assets/image-20221202105735230.C3_0LoJJ.png",La="/docs/assets/image-20221202111044434.CfBbBLUC.png",Ra="/docs/assets/image-20221202111307819.CI0cyPpW.png",Ua="/docs/assets/image-20220823200708026.DBmMw5_B.png",Fa="/docs/assets/image-20220823201303601.D917bqZe.png",Na="/docs/assets/image-20220823202344149.DPNnq_Uc.png",Va="/docs/assets/image-20221202170430928.CnVUp_iB.png",Ga="/docs/assets/image-20221202171204705.C5TLXewR.png",Ka="/docs/assets/image-20220824233452167.48iwhCpC.png",Ya="/docs/assets/image-20221202173148317.gxh0SLxT.png",Xa="/docs/assets/1530625192392.CLsI4EN4.png",za="/docs/assets/image-20220824233614686.DpaRaKht.png",Za="/docs/assets/image-20221202180119859.BeOCyXz9.png",Qa="/docs/assets/image-20221202181110555.DEBXqLvW.png",$a="/docs/assets/image-20221202180805686.DmyTrAaT.png",as="/docs/assets/image-20221202181346327.BjjSzJgE.png",ss="/docs/assets/image-20221202181651469.SqYNXJyH.png",ps="/docs/assets/image-20220824233728524.Di5NTpk6.png",ns="/docs/assets/image-20220824233903517.DzK90dcB.png",ts="/docs/assets/image-20221202184545321.De8AVxhX.png",es="/docs/assets/image-20220824234652173.r3llRcpf.png",ls="/docs/assets/image-20221202183201663.DHimPMZc.png",is="/docs/assets/image-20221202183409304.CEKthC-x.png",os="/docs/assets/image-20221202183550682.DSOqosVM.png",rs="/docs/assets/image-20220825083848086.CIZn85yV.png",cs="/docs/assets/image-20221202184753808.BYJ_yLfm.png",gs="/docs/assets/image-20221202185103941.DHztjBs8.png",ms="/docs/assets/image-20221202190033167.DRBTb-5q.png",ds="/docs/assets/image-20220825084104447.BAa7fBD2.png",hs="/docs/assets/image-20220825084017185.D3DmXYnL.png",us="/docs/assets/image-20221202195646621.Co94sp0V.png",_s="/docs/assets/image-20221202201623424.BfzbxcJ3.png",bs="/docs/assets/image-20221202200356398.DqD2vhoq.png",vs="/docs/assets/image-20221202200547676.B1q-bdWa.png",qs="/docs/assets/image-20221202200708988.Cn7dhCZ0.png",ks="/docs/assets/image-20221202201042109.DVu_924Y.png",fs="/docs/assets/image-20221202201221136.DNlFbP2k.png",Ts="/docs/assets/image-20221202201826364.BO8BSOCa.png",Ss="/docs/assets/image-20221202202305118.B7KAAvaW.png",ws="/docs/assets/image-20221202204013113.aMLZN1aa.png",Ps="/docs/assets/image-20221202204536647.BvyXyfSU.png",Ms="/docs/assets/image-20221202205103486.CYKvdOky.png",xs="/docs/assets/image-20221202205318778.CkbZROC_.png",Bs="/docs/assets/image-20220825194553137.CfIa0isi.png",js="/docs/assets/image-20220825195359993.LTa4uovG.png",Rs=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"backend/spring-boot/SpringBoot.md","filePath":"backend/spring-boot/SpringBoot.md"}'),Cs={name:"backend/spring-boot/SpringBoot.md"},Ds=e('<h2 id="maven" tabindex="-1">Maven <a class="header-anchor" href="#maven" aria-label="Permalink to &quot;Maven&quot;">​</a></h2><h2 id="springbootweb请求响应" tabindex="-1">SpringBootWeb请求响应 <a class="header-anchor" href="#springbootweb请求响应" aria-label="Permalink to &quot;SpringBootWeb请求响应&quot;">​</a></h2><h2 id="今日目标" tabindex="-1">今日目标 <a class="header-anchor" href="#今日目标" aria-label="Permalink to &quot;今日目标&quot;">​</a></h2><p>目标</p><ul><li>能够知道Maven的作用 🍐</li><li>能够安装Maven并且在Idea中配置Maven ❤️ ✏️</li><li>能够创建Maven和导入Maven工程 ❤️ ✏️</li><li>能够理解Maven的依赖配置 🍐</li><li>能够编写 SpringBoot 入门案例 ❤️ ✏️</li><li>能够理解Http协议相关概念 🍐</li><li>能够使用Tomcat运行Web项目 ✏️ 🚀</li></ul><p>知识储备</p><ol><li>理解前端为什么要工程化</li><li>理解在开发过程中要导入其他人开发的java代码，提高开发效率</li><li>曾经有过包名名字随意的经历</li><li>在前端课程中完成过，异步请求的入门案例，能理解前后端交互的场景</li><li>对于曾经分享过资源给他人，并因此而感到快乐</li></ol><h2 id="_01-maven课程介绍" tabindex="-1">01. Maven课程介绍 <a class="header-anchor" href="#_01-maven课程介绍" aria-label="Permalink to &quot;01\\. Maven课程介绍&quot;">​</a></h2><h3 id="_1-1-课程安排" tabindex="-1">1.1 课程安排 <a class="header-anchor" href="#_1-1-课程安排" aria-label="Permalink to &quot;1.1 课程安排&quot;">​</a></h3><p>学习完前端Web开发技术后，我们即将开始学习后端Web开发技术。做为一名Java开发工程师，<strong>后端Web开发技术是我们学习的重点</strong>。</p><p><img src="'+l+'" alt="image-20221130095316032"></p><blockquote><p><a href="http://www.yangeit.cn:21010/takeoutproject_optimize2021/day02.html" target="_blank" rel="noreferrer">Nginx</a>：一个高性能的HTTP和web服务器，企业中，常常用来运行前端项目</p></blockquote><p>后端Web开发技术的学习，我们会先学习Java项目的构建工具：Maven 👈</p><h3 id="_1-2-初识maven-🍐" tabindex="-1">1.2 初识Maven 🍐 <a class="header-anchor" href="#_1-2-初识maven-🍐" aria-label="Permalink to &quot;1.2 初识Maven 🍐&quot;">​</a></h3><h4 id="_1-2-1-什么是maven" tabindex="-1">1.2.1 什么是Maven <a class="header-anchor" href="#_1-2-1-什么是maven" aria-label="Permalink to &quot;1.2.1 什么是Maven&quot;">​</a></h4><p>Maven是Apache旗下的一个开源项目，是一款用于<strong>管理和构建java项目</strong>的工具。</p><p>官网：<a href="https://maven.apache.org/" target="_blank" rel="noreferrer">https://maven.apache.org/open in new window</a></p><blockquote><p>Apache 软件基金会，成立于1999年7月，是目前世界上最大的最受欢迎的开源软件基金会，也是一个专门为支持开源项目而生的非盈利性组织。</p><p>开源项目：<a href="https://www.apache.org/index.html#projects-list" target="_blank" rel="noreferrer">https://www.apache.org/index.html#projects-listopen in new window</a></p></blockquote><h4 id="_1-2-2-maven的作用" tabindex="-1">1.2.2 Maven的作用 <a class="header-anchor" href="#_1-2-2-maven的作用" aria-label="Permalink to &quot;1.2.2 Maven的作用&quot;">​</a></h4><p>问题</p><ol><li>使用Maven能够做什么呢？</li></ol><p>点击查看答案</p><ol><li>依赖管理</li><li>统一项目结构</li><li>项目构建</li></ol><p><strong>依赖管理</strong>：</p><ul><li>方便快捷的管理项目依赖的资源(jar包)，避免版本冲突问题</li></ul><p><img src="'+i+'" alt="image-20221130104014162"></p><p>当使用maven进行项目依赖(jar包)管理，则很方便的可以解决这个问题。 我们只需要在maven项目的pom.xml文件中，添加一段如下图所示的配置即可实现。</p><p><img src="'+o+'" alt="image-20220616001159531"></p><p>技巧</p><p>上述被dependency标签包裹的是依赖坐标（GAV），本机可以根据这个坐标在本地找到对应的jar包，如果要修改版本只需要修改version的数值即可</p><p><strong>统一项目结构 :</strong></p><ul><li>提供标准、统一的项目结构</li></ul><p>在项目开发中，当你使用不同的开发工具 (如：Eclipse、Idea)，创建项目工程时：</p><p><img src="'+r+'" alt="image-20221130212841973"></p><p>若我们创建的是一个maven工程，是可以帮我们自动生成统一、标准的项目目录结构：</p><p><img src="'+c+'" alt="image-20221130220539444"></p><p>具体的统一结构如下：</p><p><img src="'+g+'" alt="image-20221130140132209"></p><blockquote><p>目录说明：</p><ul><li>src/main/java: java源代码目录</li><li>src/main/resources: 配置文件信息</li><li>src/test/java: 测试代码</li><li>src/test/resources: 测试配置文件信息</li></ul></blockquote><p>技巧</p><p>因为有了相同的目录结构，哪怕企业之间使用不同的开发工具，也不需要担心，只需要记住每个目录对应的含义即可</p><p><strong>项目构建 :</strong></p><ul><li>maven提供了<strong>标准的</strong>、<strong>跨平台</strong>(Linux、Windows、MacOS) 的自动化项目构建方式</li></ul><p><img src="'+m+'" alt="image-20221130140247524"></p><p>如上图所示我们开发了一套系统，代码需要进行编译、测试、打包、发布 ，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。</p><p><img src="'+d+'" alt="image-20221130222907628"></p><p>技巧</p><p>综上所述，可以得到一个结论：<strong>Maven是一款管理和构建java项目的工具</strong></p><h2 id="_02-maven概述" tabindex="-1">02. Maven概述 <a class="header-anchor" href="#_02-maven概述" aria-label="Permalink to &quot;02\\. Maven概述&quot;">​</a></h2><p>问题</p><ol><li>pom.xml文件描述了哪些信息？</li><li>仓库是用来做什么的？主要分为哪些仓库？</li></ol><h3 id="_2-1-maven介绍" tabindex="-1">2.1 Maven介绍 <a class="header-anchor" href="#_2-1-maven介绍" aria-label="Permalink to &quot;2.1 Maven介绍&quot;">​</a></h3><p>Apache Maven是一个项目管理和构建工具，它基于项目对象模型(Project Object Model , 简称: POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。</p><p>官网：<a href="https://maven.apache.org/" target="_blank" rel="noreferrer">https://maven.apache.org/open in new window</a></p><p>Maven的作用：</p><ol><li>方便的依赖管理</li><li>统一的项目结构</li><li>标准的项目构建流程</li></ol><h3 id="_2-2-maven模型-🍐" tabindex="-1">2.2 Maven模型 🍐 <a class="header-anchor" href="#_2-2-maven模型-🍐" aria-label="Permalink to &quot;2.2 Maven模型 🍐&quot;">​</a></h3><ul><li>项目对象模型 (Project Object Model)</li><li>依赖管理模型(Dependency)</li><li>构建生命周期/阶段(Build lifecycle &amp; phases)</li></ul><p>1). <strong>构建生命周期/阶段(Build lifecycle &amp; phases)</strong></p><p><img src="'+a+'" alt="image-20221130142100703"></p><p>以上图中紫色框起来的部分，就是用来完成标准化构建流程 。当我们需要编译，Maven提供了一个编译插件供我们使用；当我们需要打包，Maven就提供了一个打包插件供我们使用等。</p><p>2). <strong>项目对象模型 (Project Object Model)</strong></p><p><img src="'+h+'" alt="image-20221130142643255"></p><p>以上图中紫色框起来的部分属于项目对象模型，就是将我们自己的项目抽象成一个对象模型，有自己专属的坐标，如下图所示是一个Maven项目：</p><p><img src="'+u+'" alt="image-20220616094113852"></p><blockquote><p>坐标，就是资源(jar包)的唯一标识，通过坐标可以定位到所需资源(jar包)位置</p><p><img src="'+_+'" alt="image-20221130230134757"></p><p>image-20221130230134757</p></blockquote><p>技巧</p><p>上述被dependency标签包裹的是依赖坐标（GAV），本机可以根据这个坐标在本地找到对应的jar包，如果要修改版本只需要修改version的数值即可</p><p>3). <strong>依赖管理模型(Dependency)</strong></p><p><img src="'+b+'" alt="image-20221130143139644"></p><p>以上图中紫色框起来的部分属于依赖管理模型，是使用坐标来描述当前项目依赖哪些第三方jar包</p><p><img src="'+v+'" alt="image-20221130174805973"></p><p>思考</p><p>如果存储jar的仓库中没有对应的版本（如1.2），而pom文件中写了这个版本如1.2，会发生什么事情尼？</p><h3 id="_2-3-maven仓库-🍐-❤️" tabindex="-1">2.3 Maven仓库 🍐 ❤️ <a class="header-anchor" href="#_2-3-maven仓库-🍐-❤️" aria-label="Permalink to &quot;2.3 Maven仓库 🍐 ❤️&quot;">​</a></h3><p>仓库：用于存储资源，管理各种jar包</p><blockquote><p>仓库的本质就是一个目录(文件夹)，这个目录被用来存储开发中所有依赖(就是jar包)和插件</p></blockquote><p>Maven仓库分为：</p><ul><li>本地仓库：自己计算机上的一个目录(用来存储jar包)</li><li>中央仓库：由Maven团队维护的全球唯一的。仓库地址：<a href="https://repo1.maven.org/maven2/" target="_blank" rel="noreferrer">https://repo1.maven.org/maven2/open in new window</a></li><li>远程仓库(私服)：一般由公司团队搭建的私有仓库</li></ul><p><img src="'+q+'" alt="image-20220616095633552"></p><p>技巧</p><p>当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包</p><ul><li><p>如果有，则在项目直接引用</p></li><li><p>如果没有，则去中央仓库中下载对应的jar包到本地仓库</p></li></ul><blockquote><p>如果还可以搭建远程仓库(私服)，将来jar包的查找顺序则变为： 本地仓库 --&gt; 远程仓库--&gt; 中央仓库 (私服知识在后面课程会学习)</p></blockquote><p>作业</p><ol><li>能够流畅的说出仓库的分类以及jar的下载流程</li><li>能够根据坐标信息找到本地仓库的jar位置，并且尝试删除jar，点击刷新后，观察jar是否会重复下载</li></ol><h3 id="_2-4-maven安装-✏️" tabindex="-1">2.4 Maven安装 ✏️ <a class="header-anchor" href="#_2-4-maven安装-✏️" aria-label="Permalink to &quot;2.4 Maven安装 ✏️&quot;">​</a></h3><p>8 分钟</p><p>认识了Maven后，我们就要开始使用Maven了，那么首先我们要进行Maven的下载与安装。</p><h4 id="_2-4-1-下载" tabindex="-1">2.4.1 下载 <a class="header-anchor" href="#_2-4-1-下载" aria-label="Permalink to &quot;2.4.1 下载&quot;">​</a></h4><p>下载地址：<a href="https://maven.apache.org/download.cgi" target="_blank" rel="noreferrer">https://maven.apache.org/download.cgiopen in new window</a></p><p>在提供的资料中，已经提供了下载好的安装包。如下：</p><p><img src="'+k+'" alt="image-20220616100211209"></p><h4 id="_2-4-2-安装步骤" tabindex="-1">2.4.2 安装步骤 <a class="header-anchor" href="#_2-4-2-安装步骤" aria-label="Permalink to &quot;2.4.2 安装步骤&quot;">​</a></h4><p>Maven安装配置步骤：</p><ol><li>解压安装</li><li>配置仓库</li><li>配置阿里云私服</li><li>配置Maven环境变量</li></ol><p><strong>1、解压 apache-maven-3.6.1-bin.zip（解压即安装）</strong></p><blockquote><p>建议解压到没有中文、特殊字符的路径下。如课程中解压到 <code>E:\\develop</code> 下。</p></blockquote><p>Gif动画 🎥</p><p><img src="'+f+'" alt=""></p><p>解压缩后的目录结构如下：</p><p><img src="'+T+'" alt="image-20220616100529868"></p><ul><li>bin目录 ： 存放的是可执行命令。（mvn 命令重点关注）</li><li>conf目录 ：存放Maven的配置文件。（settings.xml配置文件后期需要修改）</li><li>lib目录 ：存放Maven依赖的jar包。（Maven也是使用java开发的，所以它也依赖其他的jar包）</li></ul><p><strong>2、配置本地仓库</strong></p><p>2.1、在自己计算机上新一个目录（本地仓库，用来存储jar包）</p><p><img src="'+S+'" alt="image-20221130231857537"></p><p>2.2、进入到conf目录下修改settings.xml配置文件</p><p>1). 使用超级记事本软件，打开settings.xml文件，定位到53行</p><p>2). 复制<code>&lt;localRepository&gt;</code>标签，粘贴到注释的外面（55行）</p><p>3). 复制之前新建的用来存储jar包的路径，替换掉<code>&lt;localRepository&gt;</code>标签体内容</p><p><img src="'+w+`" alt=""></p><p><strong>3、配置阿里云私服</strong></p><p>由于中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。</p><p>进入到conf目录下修改settings.xml配置文件：</p><p>1). 使用超级记事本软件，打开settings.xml文件，定位到160行左右</p><p>2). 在<code>&lt;mirrors&gt;</code>标签下为其添加子标签<code>&lt;mirror&gt;</code>，内容如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>&lt;mirror&gt;  </span></span>
<span class="line"><span>    &lt;id&gt;alimaven&lt;/id&gt;  </span></span>
<span class="line"><span>    &lt;name&gt;aliyun maven&lt;/name&gt;  </span></span>
<span class="line"><span>    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span></span>
<span class="line"><span>    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;          </span></span>
<span class="line"><span>&lt;/mirror&gt;</span></span></code></pre></div><p><img src="`+P+'" alt=""></p><p>注意配置的位置，在<code>&lt;mirrors&gt;</code> ... <code>&lt;/mirrors&gt;</code> 中间添加配置。如下图所示：</p><p><img src="'+M+'" alt="image-20221130161346565"></p><p>注: 只可配置一个<code>&lt;mirror&gt;</code>(另一个要注释!) ，不然两个可能发生冲突，导致jar包无法下载!!!!!!!</p><p><strong>4、配置环境变量</strong></p><blockquote><p>Maven环境变量的配置类似于JDK环境变量配置一样</p></blockquote><p>1). 在系统变量处新建一个变量MAVEN_HOME</p><ul><li>MAVEN_HOME环境变量的值，设置为maven的解压安装目录</li></ul><p><img src="'+x+'" alt=""></p><p>2). 在Path中进行配置</p><ul><li>PATH环境变量的值，设置为：%MAVEN_HOME%\\bin</li></ul><p><img src="'+B+'" alt=""></p><p>3). 打开DOS命令提示符进行验证，出现如图所示表示安装成功</p><p><img src="'+j+'" alt="image-20220616102554143"></p><p>警告</p><p>Java项目中另外一个主流JDK是1.8，可以在本机上安装JDK1.8版本</p><p><a href="http://www.yangeit.cn:21010/takeoutproject2021/day00.html#_1-1-jdk-%E5%AE%89%E8%A3%85" target="_blank" rel="noreferrer">JDK安装教程</a></p><h2 id="_03-idea集成maven-✏️-❤️" tabindex="-1">03. IDEA集成Maven ✏️ ❤️ <a class="header-anchor" href="#_03-idea集成maven-✏️-❤️" aria-label="Permalink to &quot;03\\. IDEA集成Maven ✏️ ❤️&quot;">​</a></h2><p>我们要想在IDEA中使用Maven进行项目构建，就需要在IDEA中集成Maven</p><p>问题</p><ol><li>在Idea中配置Maven环境有几步？</li></ol><p>点击查看答案</p><ol><li>配置Maven安装位置</li><li>加载Maven的配置文件</li><li>检查本地仓库是否正常加载</li><li>检查Idea的工程编译JDK版本是否大于等于8</li></ol><h3 id="_3-1-配置maven环境" tabindex="-1">3.1 配置Maven环境 <a class="header-anchor" href="#_3-1-配置maven环境" aria-label="Permalink to &quot;3.1 配置Maven环境&quot;">​</a></h3><h4 id="_3-1-1-当前工程设置" tabindex="-1">3.1.1 当前工程设置 <a class="header-anchor" href="#_3-1-1-当前工程设置" aria-label="Permalink to &quot;3.1.1 当前工程设置&quot;">​</a></h4><p>1、<strong>选择 IDEA中 File =&gt; Settings =&gt; Build,Execution,Deployment =&gt; Build Tools =&gt; Maven</strong></p><p><img src="'+C+'" alt="image-20220616103219646"></p><p><img src="'+D+'" alt="image-20221130234731629"></p><p>2、<strong>设置IDEA使用本地安装的Maven，并修改配置文件及本地仓库路径</strong></p><p><img src="'+y+'" alt=""></p><blockquote><p>Maven home path ：指定当前Maven的安装目录</p><p>User settings file ：指定当前Maven的settings.xml配置文件的存放路径</p><p>Local repository ：指定Maven的本地仓库的路径 (如果指定了settings.xml, 这个目录会自动读取出来, 可以不用手动指定)</p></blockquote><p>3、<strong>配置工程的编译版本为11</strong></p><ul><li>Maven默认使用的编译版本为5（版本过低） 注意</li></ul><p><img src="'+s+'" alt="image-20221201093737128"></p><p>上述配置的maven环境，只是针对于当前工程的，如果我们再创建一个project，又恢复成默认的配置了。 要解决这个问题， 我们就需要配置全局的maven环境。</p><h4 id="_3-1-2-全局设置-开发实用" tabindex="-1">3.1.2 全局设置 开发实用 <a class="header-anchor" href="#_3-1-2-全局设置-开发实用" aria-label="Permalink to &quot;3.1.2 全局设置 开发实用&quot;">​</a></h4><p>1、进入到IDEA欢迎页面</p><ul><li>选择 IDEA中 File =&gt; close project</li></ul><p>Gif动画 🎥</p><p><img src="'+E+'" alt=""><img src="'+H+'" alt=""></p><p>2、打开 All settings , 选择 Build,Execution,Deployment =&gt; Build Tools =&gt; Maven</p><p><img src="'+A+'" alt=""></p><p>3、配置工程的编译版本为11</p><p><img src="'+s+'" alt="image-20221201093737128"></p><p>这里所设置的maven的环境信息，并未指定任何一个project，此时设置的信息就属于全局配置信息。 以后，我们再创建project，默认就是使用我们全局配置的信息。</p><h3 id="_3-2-maven项目" tabindex="-1">3.2 Maven项目 <a class="header-anchor" href="#_3-2-maven项目" aria-label="Permalink to &quot;3.2 Maven项目&quot;">​</a></h3><h4 id="_3-2-1-创建maven项目" tabindex="-1">3.2.1 创建Maven项目 <a class="header-anchor" href="#_3-2-1-创建maven项目" aria-label="Permalink to &quot;3.2.1 创建Maven项目&quot;">​</a></h4><p>1、创建一个空项目</p><p><img src="'+I+'" alt="image-20221201095621738"><img src="'+O+'" alt="image-20221201095600057"></p><p>2、创建模块，选择Maven，点击Next</p><p><img src="'+W+'" alt="image-20221201095831320"><img src="'+J+'" alt="image-20221201100011799"></p><p>3、填写模块名称，坐标信息，点击finish，创建完成</p><p><img src="'+L+'" alt="image-20221201100502234"></p><p>4、在Maven工程下，创建HelloWorld类</p><p><img src="'+R+'" alt="image-20221201101603397"><img src="'+U+`" alt="image-20221201101643427"></p><blockquote><ul><li><p>Maven项目的目录结构:</p><p>maven-project01 |--- src (源代码目录和测试代码目录) |--- main (源代码目录) |--- java (源代码java文件目录) |--- resources (源代码配置文件目录) |--- test (测试代码目录) |--- java (测试代码java目录) |--- resources (测试代码配置文件目录) |--- target (编译、打包生成文件存放目录)</p></li></ul></blockquote><p>5、编写 HelloWorld，并运行</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>public class HelloWorld {</span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>        System.out.println(&quot;Hello Maven ...&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="_3-2-2-pom配置详解-🍐" tabindex="-1">3.2.2 POM配置详解 🍐 <a class="header-anchor" href="#_3-2-2-pom配置详解-🍐" aria-label="Permalink to &quot;3.2.2 POM配置详解 🍐&quot;">​</a></h4><p>POM (Project Object Model) ：指的是项目对象模型，用来描述当前的maven项目。</p><ul><li>使用pom.xml文件来实现</li></ul><p>pom.xml文件：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span>
<span class="line"><span>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="line"><span>         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="line"><span>         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span></span>
<span class="line"><span>    &lt;!-- POM模型版本 --&gt;</span></span>
<span class="line"><span>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    &lt;!-- 当前项目坐标 --&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;maven_project1&lt;/artifactId&gt;</span></span>
<span class="line"><span>    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    &lt;!-- 打包方式 --&gt;</span></span>
<span class="line"><span>    &lt;packaging&gt;jar&lt;/packaging&gt;</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>&lt;/project&gt;</span></span></code></pre></div><p>pom文件详解：</p><ul><li><p><code>&lt;project&gt;</code> ：pom文件的根标签，表示当前maven项目</p></li><li><p><code>&lt;modelVersion&gt;</code> ：声明项目描述遵循哪一个POM模型版本</p><ul><li>虽然模型本身的版本很少改变，但它仍然是必不可少的。目前POM模型版本是4.0.0</li></ul></li><li><p>坐标 ：<code>&lt;groupId&gt;</code>、<code>&lt;artifactId&gt;</code>、<code>&lt;version&gt;</code></p><ul><li>定位项目在本地仓库中的位置，由以上三个标签组成一个坐标</li></ul></li><li><p><code>&lt;packaging&gt;</code> ：maven项目的打包方式，通常设置为jar或war（默认值：jar）</p></li></ul><h4 id="_3-2-3-maven坐标详解-🍐-❤️" tabindex="-1">3.2.3 Maven坐标详解 🍐 ❤️ <a class="header-anchor" href="#_3-2-3-maven坐标详解-🍐-❤️" aria-label="Permalink to &quot;3.2.3 Maven坐标详解 🍐 ❤️&quot;">​</a></h4><p>问题</p><ol><li>什么是坐标？</li></ol><p>点击查看</p><ul><li>Maven中的坐标是资源的唯一标识 , 通过该坐标可以唯一定位资源位置</li><li>使用坐标来定义项目或引入项目中需要的依赖</li></ul><p>Maven坐标主要组成</p><ul><li>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）</li><li>artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）</li><li>version：定义当前项目版本号</li></ul><p>如下图就是使用坐标表示一个项目：</p><p><img src="`+F+'" alt="image-20220616111031057"></p><blockquote><p><strong>注意：</strong></p><ul><li>上面所说的资源可以是插件、依赖、当前项目。</li><li>我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。</li></ul></blockquote><h3 id="_3-3-导入maven项目" tabindex="-1">3.3 导入Maven项目 <a class="header-anchor" href="#_3-3-导入maven项目" aria-label="Permalink to &quot;3.3 导入Maven项目&quot;">​</a></h3><p>3 分钟</p><ul><li><strong>方式1：使用Maven面板，快速导入项目</strong></li></ul><p>打开IDEA，选择右侧Maven面板，点击 + 号，选中对应项目的pom.xml文件，双击即可</p><p><img src="'+N+'" alt="image-20221201104320521"></p><p><img src="'+V+'" alt="image-20221201104906754"></p><blockquote><p>说明：如果没有Maven面板，选择 View =&gt; Appearance =&gt; Tool Window Bars</p><p><img src="'+G+'" alt="image-20220616111937679"></p><p>image-20220616111937679</p></blockquote><ul><li><strong>方式2：使用idea导入模块项目</strong></li></ul><p>File =&gt; Project Structure =&gt; Modules =&gt; + =&gt; Import Module</p><p><img src="'+K+'" alt=""></p><p>找到要导入工程的pom.xml</p><p><img src="'+Y+'" alt="image-20221201105532909"></p><p><img src="'+X+`" alt="image-20221201105845872"></p><p>作业</p><ol><li><p>创建一空项目csheima_maven，并接着创建一个Maven工程，并导入一个坐标，点击刷新按钮，观察是否引入jar包，接着依次点击compiler、package、install、clean观察对应的现象。</p></li><li><p>在项目csheima_maven下，引入一个现有的Maven工程，引入后，观察2个module是否在同级目录，同样依次点击compiler、package、install、clean观察对应的现象。</p></li></ol><h2 id="_04-依赖管理" tabindex="-1">04. 依赖管理 <a class="header-anchor" href="#_04-依赖管理" aria-label="Permalink to &quot;04\\. 依赖管理&quot;">​</a></h2><h3 id="_4-1-依赖配置" tabindex="-1">4.1 依赖配置 <a class="header-anchor" href="#_4-1-依赖配置" aria-label="Permalink to &quot;4.1 依赖配置&quot;">​</a></h3><p>问题</p><ol><li>如何配置依赖？</li><li>如果引入的依赖，在本地仓库中不存在,会发生什么？</li></ol><p>点击查看</p><ol><li><p>配置在<code>&lt;dependency&gt;</code>中配置 groupId、artifactId、version信息</p></li><li><p>如果引入的依赖，在本地仓库中不存在，将会连接远程仓库 / 中央仓库，然后下载依赖（这个过程会比较耗时，耐心等待），如果无法下载，会报红（因此可以在maven中央仓库中检索此版本是否存在）</p></li></ol><p><strong>依赖</strong>：指当前项目运行所需要的jar包 。<strong>一个项目中可以引入多个依赖</strong>：</p><blockquote><p>例如：在当前工程中，我们需要用到logback来记录日志，此时就可以在maven工程的pom.xml文件中，引入logback的依赖。具体步骤如下：</p></blockquote><ol><li><p>在pom.xml中编写<code>&lt;dependencies&gt;</code>标签</p></li><li><p>在<code>&lt;dependencies&gt;</code>标签中使用<code>&lt;dependency&gt;</code>引入坐标</p></li><li><p>定义坐标的 groupId、artifactId、version</p></li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>&lt;dependencies&gt;</span></span>
<span class="line"><span>    &lt;!-- 第1个依赖 : logback --&gt;</span></span>
<span class="line"><span>    &lt;dependency&gt;</span></span>
<span class="line"><span>        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span></span>
<span class="line"><span>        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span></span>
<span class="line"><span>        &lt;version&gt;1.2.11&lt;/version&gt;</span></span>
<span class="line"><span>    &lt;/dependency&gt;</span></span>
<span class="line"><span>    &lt;!-- 第2个依赖 : junit --&gt;</span></span>
<span class="line"><span>    &lt;dependency&gt;</span></span>
<span class="line"><span>        &lt;groupId&gt;junit&lt;/groupId&gt;</span></span>
<span class="line"><span>        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span></span>
<span class="line"><span>        &lt;version&gt;4.12&lt;/version&gt;</span></span>
<span class="line"><span>    &lt;/dependency&gt;</span></span>
<span class="line"><span>&lt;/dependencies&gt;</span></span></code></pre></div><ol start="4"><li>点击刷新按钮，引入最新加入的坐标 <ul><li>刷新依赖：保证每一次引入新的依赖，或者修改现有的依赖配置，都可以加入最新的坐标</li></ul></li></ol><p><img src="`+z+'" alt="image-20221130184402805"></p><blockquote><p>注意事项：</p><ol><li>如果引入的依赖，在本地仓库中不存在，将会连接远程仓库 / 中央仓库，然后下载依赖（这个过程会比较耗时，耐心等待）</li><li>如果不知道依赖的坐标信息，可以到mvn的中央仓库（<a href="https://mvnrepository.com/%EF%BC%89%E4%B8%AD%E6%90%9C%E7%B4%A2" target="_blank" rel="noreferrer">https://mvnrepository.com/）中搜索open in new window</a></li></ol></blockquote><p><strong>添加依赖的几种方式：</strong></p><p>Gif动画 🎥</p><ol><li><p>利用中央仓库搜索的依赖坐标 实用</p><p><img src="'+Z+'" alt=""></p></li></ol><p>开发中：直接从其他项目的pom文件中复制粘贴 简单实用 👈</p><p>Gif动画 🎥</p><ol start="2"><li><p>利用IDEA工具搜索依赖 不常用</p><p><img src="'+Q+'" alt=""></p></li></ol><p>Gif动画 🎥</p><ol start="3"><li><p>熟练上手maven后，快速导入依赖 实用</p><p><img src="'+$+'" alt=""></p></li></ol><h3 id="_4-2-依赖传递" tabindex="-1">4.2 依赖传递 <a class="header-anchor" href="#_4-2-依赖传递" aria-label="Permalink to &quot;4.2 依赖传递&quot;">​</a></h3><p>问题</p><ol><li>A 依赖 B，B 依赖 C，A 是否依赖于 C 呢？</li></ol><p>点击查看</p><p>A依赖于C，因为依赖具有传递性</p><h4 id="_4-2-1-依赖具有传递性" tabindex="-1">4.2.1 依赖具有传递性 <a class="header-anchor" href="#_4-2-1-依赖具有传递性" aria-label="Permalink to &quot;4.2.1 依赖具有传递性&quot;">​</a></h4><p>早期我们没有使用maven时，向项目中添加依赖的jar包，需要把所有的jar包都复制到项目工程下。如下图所示，需要logback-classic时，由于logback-classic又依赖了logback-core和slf4j，所以必须把这3个jar包全部复制到项目工程下</p><p><img src="'+aa+'" alt="image-20221201120514644"></p><p>我们现在使用了maven，当项目中需要使用logback-classic时，只需要在pom.xml配置文件中，添加logback-classic的依赖坐标即可。</p><p><img src="'+sa+'" alt="image-20221201113659400"></p><p>在pom.xml文件中只添加了logback-classic依赖，但由于maven的依赖具有传递性，所以会自动把所依赖的其他jar包也一起导入。</p><p>依赖传递可以分为：</p><ol><li><p><strong>直接依赖</strong>：在当前项目中通过依赖配置建立的依赖关系</p></li><li><p><strong>间接依赖</strong>：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源</p></li></ol><p><img src="'+pa+'" alt="image-20220616115445812"></p><p>比如以上图中：</p><ul><li>projectA依赖了projectB。对于projectA 来说，projectB 就是直接依赖。</li><li>而projectB依赖了projectC及其他jar包。 那么此时，在projectA中也会将projectC的依赖传递下来。对于projectA 来说，projectC就是间接依赖。</li></ul><p><img src="'+na+`" alt="image-20221201115801806"></p><h4 id="_4-2-2-排除依赖-🍐" tabindex="-1">4.2.2 排除依赖 🍐 <a class="header-anchor" href="#_4-2-2-排除依赖-🍐" aria-label="Permalink to &quot;4.2.2 排除依赖 🍐&quot;">​</a></h4><p>问题</p><ol><li>之前我们讲了依赖具有传递性。那么A依赖B，B依赖C，如果A不想将C依赖进来，是否可以做到？</li></ol><p>点击查看</p><p>在maven项目中，我们可以通过排除依赖来实现。</p><p>什么是排除依赖？</p><ul><li>排除依赖：指主动断开依赖的资源。（被排除的资源无需指定版本）</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;maven-projectB&lt;/artifactId&gt;</span></span>
<span class="line"><span>    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span></span>
<span class="line"><span>   </span></span>
<span class="line"><span>    &lt;!--排除依赖, 主动断开依赖的资源--&gt;</span></span>
<span class="line"><span>    &lt;exclusions&gt;</span></span>
<span class="line"><span>    &lt;exclusion&gt;</span></span>
<span class="line"><span>            &lt;groupId&gt;junit&lt;/groupId&gt;</span></span>
<span class="line"><span>            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span></span>
<span class="line"><span>        &lt;/exclusion&gt;</span></span>
<span class="line"><span>    &lt;/exclusions&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre></div><p>依赖排除示例：</p><ul><li>maven-projectA依赖了maven-projectB，maven-projectB依赖了Junit。基于依赖的传递性，所以maven-projectA也依赖了Junit</li></ul><p><img src="`+ta+'" alt="image-20221201141929240"></p><ul><li>使用排除依赖后</li></ul><p><img src="'+ea+'" alt="image-20221201142501556"></p><h3 id="_4-3-依赖范围" tabindex="-1">4.3 依赖范围 <a class="header-anchor" href="#_4-3-依赖范围" aria-label="Permalink to &quot;4.3 依赖范围&quot;">​</a></h3><p>问题</p><ol><li>开发中，常用的依赖范围是哪种？</li></ol><p>点击查看</p><p>开发中最常用的是compile（默认） 如果是单元测试的依赖，可以配置 test</p><p>在项目中导入依赖的jar包后，默认情况下，可以在任何地方使用。</p><p><img src="'+la+'" alt="image-20221201135142706"></p><p>如果希望限制依赖的使用范围，可以通过<code>&lt;scope&gt;</code>标签设置其作用范围。</p><p><img src="'+ia+'" alt="image-20220616123806894"></p><p>作用范围：</p><ol><li><p>主程序范围有效（main文件夹范围内）</p></li><li><p>测试程序范围有效（test文件夹范围内）</p></li><li><p>是否参与打包运行（package指令范围内）</p></li></ol><p><img src="'+oa+'" alt="image-20221201140140947"></p><p>如上图所示，给junit依赖通过scope标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。</p><p>scope标签的取值范围：</p><table><thead><tr><th><strong>scope</strong>值</th><th><strong>主程序</strong></th><th><strong>测试程序</strong></th><th><strong>打包（运行）</strong></th><th><strong>范例</strong></th></tr></thead><tbody><tr><td>compile（默认）</td><td>Y</td><td>Y</td><td>Y</td><td>log4j</td></tr><tr><td>test</td><td>-</td><td>Y</td><td>-</td><td>junit</td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td>runtime</td><td>-</td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr></tbody></table><h3 id="_4-4-生命周期-🍐" tabindex="-1">4.4 生命周期 🍐 <a class="header-anchor" href="#_4-4-生命周期-🍐" aria-label="Permalink to &quot;4.4 生命周期 🍐&quot;">​</a></h3><p>问题</p><ol><li>Maven中有几套生命周期，生命周期相互依赖吗？</li><li>当运行package生命周期时，clean、compile生命周期会不会运行？</li></ol><p>点击查看</p><p>Maven对项目构建的生命周期划分为3套，分别为：</p><ul><li>clean：清理工作。</li><li>default：核心工作。如：编译、测试、打包、安装、部署等。</li><li>site：生成报告、发布站点等。</li></ul><p>生命周期的顺序是：clean --&gt; validate --&gt; compile --&gt; test --&gt; package --&gt; verify --&gt; install --&gt; site --&gt; deploy</p><p>我们需要关注的就是：clean --&gt; compile --&gt; test --&gt; package --&gt; install</p><p>👉 ：生命周期之间相互独立， 在同一套生命周期中，我们在执行后面的生命周期时，前面的生命周期都会执行。</p><p>⚠️ 思考：当运行package生命周期时，clean、compile生命周期会不会运行？</p><p>👉 clean不会运行，compile会运行。 因为compile与package属于同一套生命周期，而clean与package不属于同一套生命周期。</p><h4 id="_4-4-1-介绍" tabindex="-1">4.4.1 介绍 <a class="header-anchor" href="#_4-4-1-介绍" aria-label="Permalink to &quot;4.4.1 介绍&quot;">​</a></h4><p>Maven的生命周期就是为了对所有的构建过程进行抽象和统一。 描述了一次项目构建，经历哪些阶段。</p><p>在Maven出现之前，项目构建的生命周期就已经存在，软件开发人员每天都在对项目进行清理，编译，测试及部署。虽然大家都在不停地做构建工作，但公司和公司间、项目和项目间，往往使用不同的方式做类似的工作。</p><p>Maven从大量项目和构建工具中学习和反思，然后总结了一套高度完美的，易扩展的项目构建生命周期。这个生命周期包含了项目的清理，初始化，编译，测试，打包，集成测试，验证，部署和站点生成等几乎所有构建步骤通用性强。</p><p>Maven对项目构建的生命周期划分为3套（相互独立）：</p><p><img src="'+ra+'" alt=""></p><ul><li><p>clean：清理工作。</p></li><li><p>default：核心工作。如：编译、测试、打包、安装、部署等。</p></li><li><p>site：生成报告、发布站点等。</p></li></ul><p>三套生命周期又包含哪些具体的阶段呢, 我们来看下面这幅图:</p><p><img src="'+ca+'" alt="image-20220616124348972"></p><p>我们看到这三套生命周期，里面有很多很多的阶段，这么多生命周期阶段，其实我们常用的并不多，主要关注以下几个：</p><p>主要指令</p><ul><li>clean：移除上一次构建生成的文件</li></ul><hr><ul><li>compile：编译项目源代码</li><li>test：使用合适的单元测试框架运行测试(junit)</li><li>package：将编译后的文件打包，如：jar、war等</li><li>install：安装项目到本地仓库</li></ul><p>Maven的生命周期是抽象的，这意味着生命周期本身不做任何实际工作。<strong>在Maven的设计中，实际任务（如源代码编译）都交由插件来完成。</strong></p><p><img src="'+a+'" alt="image-20221130142100703"></p><p>IDEA工具为了方便程序员使用maven生命周期，在右侧的maven工具栏中，已给出快速访问通道</p><p><img src="'+ga+'" alt="image-20221201151340340"></p><h4 id="_4-4-2-执行" tabindex="-1">4.4.2 执行 <a class="header-anchor" href="#_4-4-2-执行" aria-label="Permalink to &quot;4.4.2 执行&quot;">​</a></h4><p>在日常开发中，当我们要执行指定的生命周期时，有两种执行方式：</p><ol><li>在idea工具右侧的maven工具栏中，选择对应的生命周期，双击执行</li><li>在DOS命令行中，通过maven命令执行</li></ol><p><strong>方式一：在idea中执行生命周期</strong></p><ul><li>选择对应的生命周期，双击执行</li></ul><p><img src="'+ma+'" alt="image-20221201161957301"></p><p><img src="'+da+'" alt="image-20221201163711835"></p><p><img src="'+ha+'" alt="image-20221201164627403"></p><p><img src="'+ua+'" alt="image-20221201165801341"></p><p><img src="'+_a+'" alt="image-20221201170830837"></p><p>clean：</p><p><img src="'+ba+'" alt="image-20221201171529382"></p><p><strong>方式二：在命令行中执行生命周期</strong></p><ol><li>进入到DOS命令行</li></ol><p><img src="'+va+'" alt="image-20221201172210253"></p><p><img src="'+qa+'" alt="image-20221201172914648"></p><h2 id="_05-附录-🚀-✏️" tabindex="-1">05. 附录 🚀 ✏️ <a class="header-anchor" href="#_05-附录-🚀-✏️" aria-label="Permalink to &quot;05\\. 附录 🚀 ✏️&quot;">​</a></h2><h3 id="_5-1-更新依赖索引-实用技巧" tabindex="-1">5.1 更新依赖索引 实用技巧 <a class="header-anchor" href="#_5-1-更新依赖索引-实用技巧" aria-label="Permalink to &quot;5.1 更新依赖索引 实用技巧&quot;">​</a></h3><p>有时候给idea配置完maven仓库信息后，在idea中依然搜索不到仓库中的jar包。这是因为仓库中的jar包索引尚未更新到idea中。这个时候我们就需要更新idea中maven的索引了，具体做法如下：</p><p>打开设置----搜索maven----Repositories----选中本地仓库-----点击Update</p><p><img src="'+ka+'" alt="1537786634456"></p><p>1537786634456</p><h3 id="_5-2-清理maven仓库-实用技巧" tabindex="-1">5.2 清理maven仓库 实用技巧 <a class="header-anchor" href="#_5-2-清理maven仓库-实用技巧" aria-label="Permalink to &quot;5.2 清理maven仓库 实用技巧&quot;">​</a></h3><p>初始情况下，我们的本地仓库是没有任何jar包的，此时会从私服去下载（如果没有配置，就直接从中央仓库去下载），可能由于网络的原因，jar包下载不完全，这些不完整的jar包都是以lastUpdated结尾。此时，maven不会再重新帮你下载，需要你删除这些以lastUpdated结尾的文件，然后maven才会再次自动下载这些jar包。</p><p><img src="'+fa+`" alt="lastUpdate"></p><p>lastUpdate</p><p>如果本地仓库中有很多这样的以lastUpadted结尾的文件，可以定义一个批处理文件，在其中编写如下脚本来删除：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>set REPOSITORY_PATH=E:\\develop\\apache-maven-3.6.1\\mvn_repo</span></span>
<span class="line"><span>rem 正在搜索...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>del /s /q %REPOSITORY_PATH%\\*.lastUpdated</span></span>
<span class="line"><span></span></span>
<span class="line"><span>rem 搜索完毕</span></span>
<span class="line"><span>pause</span></span></code></pre></div><p>操作步骤如下：</p><p>1). 定义批处理文件del_lastUpdated.bat (直接创建一个文本文件，命名为del_lastUpdated，后缀名直接改为bat即可 )</p><p><img src="`+Ta+'" alt="image-20221214154949482"></p><p>2). 在上面的bat文件上<strong>右键---》编辑</strong> 。修改文件：</p><p><img src="'+Sa+'" alt="image-20221214154559817"></p><p>修改完毕后，双击运行即可删除maven仓库中的残留文件。</p><hr><h2 id="_06-web入门课程介绍" tabindex="-1">06. web入门课程介绍 <a class="header-anchor" href="#_06-web入门课程介绍" aria-label="Permalink to &quot;06\\. web入门课程介绍&quot;">​</a></h2><p>问题</p><ol><li>为什么要学习SpringBoot？</li></ol><p>点击查看代码</p><p>通过springboot就可以快速的帮我们构建应用程序，springboot最大的特点 ：</p><ul><li>简化配置</li><li>快速开发</li><li>企业开发主流</li></ul><p><strong>Spring Boot 可以帮助我们非常快速的构建应用程序、简化开发、提高效率 。</strong></p><p>Spring的官方提供很多开源的项目，我们可以点击上面的projects，看到spring家族旗下的项目，按照流行程度排序为：</p><p><img src="'+wa+'" alt=""></p><p>Spring发展到今天已经形成了一种<strong>开发生态圈</strong>，Spring提供了若干个子项目，每个项目用于完成特定的功能。而我们在项目开发时，一般会偏向于选择这一套spring家族的技术，来解决对应领域的问题，那我们称这一套技术为<strong>spring全家桶</strong>。</p><p><img src="'+Pa+'" alt=""></p><p>而Spring家族旗下这么多的技术，最基础、最核心的是 SpringFramework 。其他的spring家族的技术，都是基于SpringFramework的，SpringFramework中提供很多实用功能，如：依赖注入、事务管理、web开发支持、数据访问、消息服务等等。</p><p><img src="'+Ma+'" alt=""></p><p><strong>而如果我们在项目中，直接基于SpringFramework进行开发，存在两个问题：配置繁琐、入门难度大。</strong> ⚠️ ⚠️</p><p><img src="'+xa+'" alt=""></p><p>所以基于此呢，spring官方推荐我们从另外一个项目开始学习，那就是目前最火爆的SpringBoot。 企业非常实用</p><p>作业</p><ol><li>访问spring官网，借助翻译软件了解Spring的简介</li><li>借助翻译软件，了解4个的Spring子项目的作用和应用场景</li></ol><h2 id="_07-springboot快速入门-❤️-👈" tabindex="-1">07. SpringBoot快速入门 ❤️ 👈 <a class="header-anchor" href="#_07-springboot快速入门-❤️-👈" aria-label="Permalink to &quot;07\\. SpringBoot快速入门 ❤️ 👈&quot;">​</a></h2><h3 id="_7-1-需求" tabindex="-1">7.1 需求 <a class="header-anchor" href="#_7-1-需求" aria-label="Permalink to &quot;7.1 需求&quot;">​</a></h3><p>需求</p><ol><li>基于SpringBoot的方式开发一个web应用，浏览器发起请求/hello后，给浏览器返回字符串 “Hello World ~”。</li></ol><p><img src="'+Ba+'" alt=""></p><h3 id="_7-2-开发步骤-✏️" tabindex="-1">7.2 开发步骤 ✏️ <a class="header-anchor" href="#_7-2-开发步骤-✏️" aria-label="Permalink to &quot;7.2 开发步骤 ✏️&quot;">​</a></h3><p>步骤</p><ul><li>第1步：创建SpringBoot工程项目</li><li>第2步：定义HelloController类，添加方法hello，并添加注解</li><li>第3步：测试运行</li></ul><h4 id="_7-2-1-创建springboot工程-需要联网" tabindex="-1">7.2.1 创建SpringBoot工程（需要联网） <a class="header-anchor" href="#_7-2-1-创建springboot工程-需要联网" aria-label="Permalink to &quot;7.2.1 创建SpringBoot工程（需要联网）&quot;">​</a></h4><p>基于Spring官方骨架，创建SpringBoot工程。</p><p><img src="'+ja+'" alt="image-20221201184702136"></p><p>基本信息描述完毕之后，勾选web开发相关依赖。</p><p><img src="'+Ca+'" alt="image-20221201184850248"></p><p>点击Finish之后，就会联网创建这个SpringBoot工程，创建好之后，结构如下：</p><ul><li>注意：在联网创建过程中，会下载相关资源(请耐心等待)</li></ul><p><img src="'+Da+'" alt="image-20221201185910596"></p><h4 id="_7-2-2-定义请求处理类" tabindex="-1">7.2.2 定义请求处理类 <a class="header-anchor" href="#_7-2-2-定义请求处理类" aria-label="Permalink to &quot;7.2.2 定义请求处理类&quot;">​</a></h4><p>在com.itheima这个包下创建一个子包controller</p><p><img src="'+ya+'" alt="image-20221201190541295"></p><p>然后在controller包下新建一个类：HelloController</p><p><img src="'+Ea+`" alt="image-20221201190825439"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>package com.itheima.controller;</span></span>
<span class="line"><span>import org.springframework.web.bind.annotation.*;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//表明当前类用来接受web请求</span></span>
<span class="line"><span>@RestController</span></span>
<span class="line"><span>public class HelloController {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 配置访问该方法的路径：localhost:8080/hello</span></span>
<span class="line"><span>    @RequestMapping(&quot;/hello&quot;)</span></span>
<span class="line"><span>    public String hello(){</span></span>
<span class="line"><span>        System.out.println(&quot;Hello World ~&quot;);</span></span>
<span class="line"><span>        return &quot;Hello World ~&quot;;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="_7-2-3-运行测试" tabindex="-1">7.2.3 运行测试 <a class="header-anchor" href="#_7-2-3-运行测试" aria-label="Permalink to &quot;7.2.3 运行测试&quot;">​</a></h4><p>运行SpringBoot自动生成的引导类</p><p><img src="`+Ha+'" alt="image-20221201191028124"></p><p><img src="'+Aa+'" alt="image-20221201191348924"></p><p>打开浏览器，输入 <code>http://localhost:8080/hello</code></p><p><img src="'+Ia+'" alt=""></p><p>作业</p><p>🚩 根据上述的步骤，创建一个SpringBoot项目，在浏览器访问localhost:8080/csheima 后，控制台输出 spring makes java simple</p><p>完成后，在飞秋班级群中，回复1，表示完成。🎉</p><h3 id="_7-3-web分析" tabindex="-1">7.3 Web分析 <a class="header-anchor" href="#_7-3-web分析" aria-label="Permalink to &quot;7.3 Web分析&quot;">​</a></h3><p>问题</p><ol><li>网络编程三要素分别？</li><li>浏览器和服务器两端进行数据交互，使用什么协议？</li></ol><p>点击查看代码</p><ul><li><p>👉 问题1： ip、端口、协议</p><ul><li>IP ：网络中计算机的唯一标识</li><li>端口 ：计算机中运行程序的唯一标识</li><li>协议 ：网络中计算机之间交互的规则</li></ul></li><li><p>👉 问题2：http协议</p></li></ul><p><img src="'+Oa+'" alt="image-20221201224603497"></p><p>点击查看图解说明</p><p>📱浏览器：</p><ul><li><p>输入网址：<code>http://192.168.100.11:8080/hello</code></p><ul><li><p>通过IP地址192.168.100.11定位到网络上的一台计算机</p><blockquote><p>我们之前在浏览器中输入的localhost，就是127.0.0.1（本机）</p></blockquote></li><li><p>通过端口号8080找到计算机上运行的程序</p><blockquote><p><code>localhost:8080</code> , 意思是在本地计算机中找到正在运行的8080端口的程序</p></blockquote></li><li><p>/hello是请求资源位置</p><ul><li>资源：对计算机而言资源就是数据 <ul><li>web资源：通过网络可以访问到的资源（通常是指存放在服务器上的数据）</li></ul></li></ul><blockquote><p><code>localhost:8080/hello</code> ，意思是向本地计算机中的8080端口程序，获取资源位置是/hello的数据</p><ul><li>8080端口程序，在服务器找/hello位置的资源数据，发给浏览器</li></ul></blockquote></li></ul></li></ul><p>💻 服务器：（可以理解为ServerSocket）</p><ul><li>接收到浏览器发送的信息（如：/hello）</li><li>在服务器上找到/hello的资源</li><li>把资源发送给浏览器</li></ul><h2 id="_08-http协议-🍐" tabindex="-1">08. HTTP协议 🍐 <a class="header-anchor" href="#_08-http协议-🍐" aria-label="Permalink to &quot;08\\. HTTP协议 🍐&quot;">​</a></h2><h3 id="_8-1-http-概述" tabindex="-1">8.1 HTTP-概述 <a class="header-anchor" href="#_8-1-http-概述" aria-label="Permalink to &quot;8.1 HTTP-概述&quot;">​</a></h3><p>问题</p><ol><li>Http协议有哪些特点？</li></ol><p>点击查看代码</p><ul><li><p><strong>基于TCP协议:</strong> 面向连接，安全</p><blockquote><p>TCP是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全</p></blockquote></li><li><p><strong>基于请求-响应模型:</strong> 一次请求对应一次响应（先请求后响应）</p><blockquote><p>请求和响应是一一对应关系，没有请求，就没有响应</p></blockquote></li><li><p><strong>HTTP协议是无状态协议:</strong> 对于数据没有记忆能力。每次请求-响应都是独立的</p><blockquote><p>无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。</p><ul><li>缺点: 多次请求间不能共享数据</li><li>优点: 速度快</li></ul><p>请求之间无法共享数据会引发的问题：</p><ul><li>如：京东购物。加入购物车和去购物车结算是两次请求</li><li>由于HTTP协议的无状态特性，加入购物车请求响应结束后，并未记录加入购物车是何商品</li><li>发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据</li></ul><p>具体使用的时候，我们发现京东是可以正常展示数据的，原因是Java早已考虑到这个问题，并提出了使用会话技术(Cookie、Session)来解决这个问题。</p></blockquote></li></ul><h4 id="_8-1-1-介绍" tabindex="-1">8.1.1 介绍 <a class="header-anchor" href="#_8-1-1-介绍" aria-label="Permalink to &quot;8.1.1 介绍&quot;">​</a></h4><p><img src="'+Wa+'" alt=""></p><p>HTTP：Hyper Text Transfer Protocol(超文本传输协议)，规定了浏览器与服务器之间数据传输的规则。</p><ul><li>1️⃣ http是互联网上应用最为广泛的一种网络协议</li><li>2️⃣ http协议要求：浏览器在向服务器发送请求数据时，或是服务器在向浏览器发送响应数据时，都必须按照固定的格式进行数据传输</li></ul><p>如果想知道http协议的数据传输格式有哪些，可以打开浏览器，点击`F12`打开开发者工具，点击`Network`来查看</p><p>点击查看步骤</p><p><img src="'+Ja+'" alt="image-20221202105735230"></p><p>浏览器向服务器进行请求时：</p><ul><li>服务器按照固定的格式进行解析</li></ul><p><img src="'+La+'" alt="image-20221202111044434"></p><p>服务器向浏览器进行响应时：</p><ul><li>浏览器按照固定的格式进行解析</li></ul><p><img src="'+Ra+'" alt="image-20221202111307819"></p><p>技巧</p><p>学习HTTP主要就是学习请求和响应数据的具体格式内容</p><h3 id="_8-2-http-请求协议" tabindex="-1">8.2 HTTP-请求协议 <a class="header-anchor" href="#_8-2-http-请求协议" aria-label="Permalink to &quot;8.2 HTTP-请求协议&quot;">​</a></h3><p>问题</p><ol><li>Get和Post请求方式有什么区别？</li></ol><p>点击查看</p><table><thead><tr><th>区别方式</th><th>GET请求</th><th>POST请求</th></tr></thead><tbody><tr><td>请求参数</td><td>请求参数在请求行中。</td><td></td></tr><tr><td>例：/brand/findAll?name=OPPO&amp;status=1</td><td>请求参数在请求体中</td><td></td></tr><tr><td>请求参数长度</td><td>请求参数长度有限制(浏览器不同限制也不同)</td><td>请求参数长度没有限制</td></tr><tr><td>安全性</td><td>安全性低。原因：请求参数暴露在浏览器地址栏中。</td><td>安全性相对高</td></tr></tbody></table><p>浏览器和服务器是按照HTTP协议进行数据通信的。</p><p>HTTP协议又分为：请求协议和响应协议</p><ul><li>请求协议：浏览器将数据以请求格式发送到服务器 <ul><li>包括：<strong>请求行</strong>、<strong>请求头</strong> 、<strong>请求体</strong></li></ul></li><li>响应协议：服务器将数据以响应格式返回给浏览器 <ul><li>包括：<strong>响应行</strong> 、<strong>响应头</strong> 、<strong>响应体</strong></li></ul></li></ul><p>点击查看HTTP1.1版本中，浏览器访问服务器的几种方式：</p><table><thead><tr><th>请求方式</th><th>请求说明</th></tr></thead><tbody><tr><td>GET</td><td>获取资源。</td></tr><tr><td>向特定的资源发出请求。例：<a href="http://www.baidu.com/s?wd=itheima" target="_blank" rel="noreferrer">http://www.baidu.com/s?wd=itheimaopen in new window</a></td><td></td></tr><tr><td>POST</td><td>传输实体主体。</td></tr><tr><td>向指定资源提交数据进行处理请求（例：上传文件），数据被包含在请求体中。</td><td></td></tr><tr><td>OPTIONS</td><td>返回服务器针对特定资源所支持的HTTP请求方式。</td></tr><tr><td>因为并不是所有的服务器都支持规定的方法，为了安全有些服务器可能会禁止掉一些方法，例如：DELETE、PUT等。那么OPTIONS就是用来询问服务器支持的方法。</td><td></td></tr><tr><td>HEAD</td><td>获得报文首部。</td></tr><tr><td>HEAD方法类似GET方法，但是不同的是HEAD方法不要求返回数据。通常用于确认URI的有效性及资源更新时间等。</td><td></td></tr><tr><td>PUT</td><td>传输文件。</td></tr><tr><td>PUT方法用来传输文件。类似FTP协议，文件内容包含在请求报文的实体中，然后请求保存到URL指定的服务器位置。</td><td></td></tr><tr><td>DELETE</td><td>删除文件。</td></tr><tr><td>请求服务器删除Request-URI所标识的资源</td><td></td></tr><tr><td>TRACE</td><td>追踪路径。</td></tr><tr><td>回显服务器收到的请求，主要用于测试或诊断</td><td></td></tr><tr><td>CONNECT</td><td>要求用隧道协议连接代理。</td></tr><tr><td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td><td></td></tr></tbody></table><p>在我们实际应用中常用的也就是 ：GET、POST</p><p><strong>GET方式的请求协议：</strong></p><p><img src="'+Ua+`" alt=""></p><ul><li><p>请求行 ：HTTP请求中的第一行数据。由：<code>请求方式</code>、<code>资源路径</code>、<code>协议/版本</code>组成（之间使用空格分隔）</p><ul><li>请求方式：GET</li><li>资源路径：/brand/findAll?name=OPPO&amp;status=1 <ul><li>请求路径：/brand/findAll</li><li>请求参数：name=OPPO&amp;status=1 <ul><li>请求参数是以key=value形式出现</li><li>多个请求参数之间使用<code>&amp;</code>连接</li></ul></li><li>请求路径和请求参数之间使用<code>?</code>连接</li></ul></li><li>协议/版本：HTTP/1.1</li></ul></li><li><p>请求头 ：第二行开始，上图黄色部分内容就是请求头。格式为key: value形式</p><ul><li>http是个无状态的协议，所以在请求头设置浏览器的一些自身信息和想要响应的形式。这样服务器在收到信息后，就可以知道是谁，想干什么了</li></ul><p>常见的HTTP请求头有:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>Host: 表示请求的主机名</span></span>
<span class="line"><span></span></span>
<span class="line"><span>User-Agent: 浏览器版本。 例如：Chrome浏览器的标识类似Mozilla/5.0 ...Chrome/79 ，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...)like Gecko</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有；</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Content-Type：请求主体的数据类型</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Content-Length：数据主体的大小（单位：字节）</span></span></code></pre></div></li></ul><blockquote><p>举例说明：服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求。</p><p>比如:</p><ul><li>不同浏览器解析HTML和CSS标签的结果会有不一致，所以就会导致相同的代码在不同的浏览器会出现不同的效果</li><li>服务端根据客户端请求头中的数据获取到客户端的浏览器类型，就可以根据不同的浏览器设置不同的代码来达到一致的效果（这就是我们常说的浏览器兼容问题）</li></ul></blockquote><ul><li>请求体 ：存储请求参数 <ul><li>GET请求的请求参数在请求行中，故不需要设置请求体</li></ul></li></ul><p><strong>POST方式的请求协议：</strong></p><p><img src="`+Fa+'" alt=""></p><ul><li>请求行 (以上图中红色部分)：包含请求方式、资源路径、协议/版本 <ul><li>请求方式：POST</li><li>资源路径：/brand</li><li>协议/版本：HTTP/1.1</li></ul></li><li>请求头 (以上图中黄色部分)</li><li>请求体 (以上图中绿色部分) ：存储请求参数 <ul><li>请求体和请求头之间是有一个空行隔开（作用：用于标记请求头结束）</li></ul></li></ul><h3 id="_8-3-http-响应协议" tabindex="-1">8.3 HTTP-响应协议 <a class="header-anchor" href="#_8-3-http-响应协议" aria-label="Permalink to &quot;8.3 HTTP-响应协议&quot;">​</a></h3><p>问题</p><ol><li>常用的响应状态码有哪些？</li></ol><p>点击查看代码</p><p>关于响应状态码，我们先主要认识三个状态码，其余的等后期用到了再去掌握：</p><ul><li>200 ok 客户端请求成功</li><li>404 Not Found 请求资源不存在</li><li>500 Internal Server Error 服务端发生不可预期的错误</li></ul><p><a href="http://www.yangeit.cn:21010/expand/responsestatuscode.html" target="_blank" rel="noreferrer">响应状态码详情</a></p><h4 id="_8-3-1-格式介绍" tabindex="-1">8.3.1 格式介绍 <a class="header-anchor" href="#_8-3-1-格式介绍" aria-label="Permalink to &quot;8.3.1 格式介绍&quot;">​</a></h4><p>与HTTP的请求一样，HTTP响应的数据也分为3部分：<strong>响应行</strong>、<strong>响应头</strong> 、<strong>响应体</strong></p><p><img src="'+Na+`" alt=""></p><ul><li><p>响应行 (以上图中红色部分)：响应数据的第一行。响应行由<code>协议及版本</code>、<code>响应状态码</code>、<code>状态码描述</code>组成</p><ul><li>协议/版本：HTTP/1.1</li><li>响应状态码：200</li><li>状态码描述：OK</li></ul></li><li><p>响应头 (以上图中黄色部分)：响应数据的第二行开始。格式为key：value形式</p><ul><li>http是个无状态的协议，所以可以在请求头和响应头中设置一些信息和想要执行的动作，这样，对方在收到信息后，就可以知道你是谁，你想干什么</li></ul><p>常见的HTTP响应头有:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>Content-Type：表示该响应内容的类型，例如text/html，image/jpeg ；</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Content-Length：表示该响应内容的长度（字节数）；</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Content-Encoding：表示该响应压缩算法，例如gzip ；</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒 ;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Set-Cookie: 告诉浏览器为当前页面所在的域设置cookie ;</span></span></code></pre></div></li><li><p>响应体 (以上图中绿色部分)： 响应数据的最后一部分。存储响应的数据</p><ul><li>响应体和响应头之间有一个空行隔开（作用：用于标记响应头结束）</li></ul></li></ul><h3 id="_8-4-http-协议解析🚀" tabindex="-1">8.4 HTTP-协议解析🚀 <a class="header-anchor" href="#_8-4-http-协议解析🚀" aria-label="Permalink to &quot;8.4 HTTP-协议解析🚀&quot;">​</a></h3><p>问题</p><ol><li>运行web程序，需要开发者编写程序解析Http协议吗？</li></ol><p>点击查看代码</p><p>不需要，直接使用已经开发好的服务器即可。</p><p>点击查看解析Http案例代码</p><p>将资料中准备好的Demo工程，导入到我们的IDEA中，有一个Server.java类，这里面就是自定义的一个服务器代码，主要使用到的是<code>ServerSocket</code>和<code>Socket</code></p><blockquote><p>说明：以下代码大家不需要自己写，我们主要是通过代码，让大家了解到服务器针对HTTP协议的解析机制</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light dracula-soft vp-code"><code><span class="line"><span>package com.itheima;</span></span>
<span class="line"><span>/*</span></span>
<span class="line"><span> * 自定义web服务器</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>public class Server {</span></span>
<span class="line"><span>    public static void main(String[] args) throws IOException {</span></span>
<span class="line"><span>        ServerSocket ss = new ServerSocket(8080); // 监听指定端口</span></span>
<span class="line"><span>        System.out.println(&quot;server is running...&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        while (true){</span></span>
<span class="line"><span>            Socket sock = ss.accept();</span></span>
<span class="line"><span>            System.out.println(&quot;connected from &quot; + sock.getRemoteSocketAddress());</span></span>
<span class="line"><span>            Thread t = new Handler(sock);</span></span>
<span class="line"><span>            t.start();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Handler extends Thread {</span></span>
<span class="line"><span>    Socket sock;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public Handler(Socket sock) {</span></span>
<span class="line"><span>        this.sock = sock;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public void run() {</span></span>
<span class="line"><span>        try (InputStream input = this.sock.getInputStream();</span></span>
<span class="line"><span>             OutputStream output = this.sock.getOutputStream()) {</span></span>
<span class="line"><span>                handle(input, output);</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            try {</span></span>
<span class="line"><span>                this.sock.close();</span></span>
<span class="line"><span>            } catch (IOException ioe) {</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            System.out.println(&quot;client disconnected.&quot;);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private void handle(InputStream input, OutputStream output) throws IOException {</span></span>
<span class="line"><span>        BufferedReader reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));</span></span>
<span class="line"><span>        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));</span></span>
<span class="line"><span>        // 读取HTTP请求:</span></span>
<span class="line"><span>        boolean requestOk = false;</span></span>
<span class="line"><span>        String first = reader.readLine();</span></span>
<span class="line"><span>        if (first.startsWith(&quot;GET / HTTP/1.&quot;)) {</span></span>
<span class="line"><span>            requestOk = true;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        for (;;) {</span></span>
<span class="line"><span>            String header = reader.readLine();</span></span>
<span class="line"><span>            if (header.isEmpty()) { // 读取到空行时, HTTP Header读取完毕</span></span>
<span class="line"><span>                break;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            System.out.println(header);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        System.out.println(requestOk ? &quot;Response OK&quot; : &quot;Response Error&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if (!requestOk) {// 发送错误响应:</span></span>
<span class="line"><span>            writer.write(&quot;HTTP/1.0 404 Not Found\\r\\n&quot;);</span></span>
<span class="line"><span>            writer.write(&quot;Content-Length: 0\\r\\n&quot;);</span></span>
<span class="line"><span>            writer.write(&quot;\\r\\n&quot;);</span></span>
<span class="line"><span>            writer.flush();</span></span>
<span class="line"><span>        } else {// 发送成功响应:</span></span>
<span class="line"><span>            //读取html文件，转换为字符串</span></span>
<span class="line"><span>            InputStream is = Server.class.getClassLoader().getResourceAsStream(&quot;html/a.html&quot;);</span></span>
<span class="line"><span>            BufferedReader br = new BufferedReader(new InputStreamReader(is));</span></span>
<span class="line"><span>            StringBuilder data = new StringBuilder();</span></span>
<span class="line"><span>            String line = null;</span></span>
<span class="line"><span>            while ((line = br.readLine()) != null){</span></span>
<span class="line"><span>                data.append(line);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            br.close();</span></span>
<span class="line"><span>            int length = data.toString().getBytes(StandardCharsets.UTF_8).length;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            writer.write(&quot;HTTP/1.1 200 OK\\r\\n&quot;);</span></span>
<span class="line"><span>            writer.write(&quot;Connection: keep-alive\\r\\n&quot;);</span></span>
<span class="line"><span>            writer.write(&quot;Content-Type: text/html\\r\\n&quot;);</span></span>
<span class="line"><span>            writer.write(&quot;Content-Length: &quot; + length + &quot;\\r\\n&quot;);</span></span>
<span class="line"><span>            writer.write(&quot;\\r\\n&quot;); // 空行标识Header和Body的分隔</span></span>
<span class="line"><span>            writer.write(data.toString());</span></span>
<span class="line"><span>            writer.flush();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>启动ServerSocket程序：</p><p><img src="`+Va+'" alt="image-20221202170430928"></p><p>浏览器输入：<code>http://localhost:8080</code> 就会访问到ServerSocket程序</p><ul><li>ServerSocket程序，会读取服务器上<code>html/a.html</code>文件，并把文件数据发送给浏览器</li><li>浏览器接收到a.html文件中的数据后进行解析，显示以下内容</li></ul><p><img src="'+Ga+'" alt="image-20221202171204705"></p><p>现在大家知道了服务器是可以使用java完成编写，是可以接受页面发送的请求和响应数据给前端浏览器的，而在开发中真正用到的Web服务器，我们不会自己写的，都是使用目前比较流行的web服务器。如：<strong>Tomcat</strong></p><p><img src="'+Ka+'" alt=""></p><h2 id="_09-web服务器-tomcat-🍐🚀" tabindex="-1">09. WEB服务器-Tomcat 🍐🚀 <a class="header-anchor" href="#_09-web服务器-tomcat-🍐🚀" aria-label="Permalink to &quot;09\\. WEB服务器-Tomcat 🍐🚀&quot;">​</a></h2><h3 id="_9-1-简介" tabindex="-1">9.1 简介 <a class="header-anchor" href="#_9-1-简介" aria-label="Permalink to &quot;9.1 简介&quot;">​</a></h3><p>问题</p><ol><li>web服务器有什么作用？</li></ol><p>点击查看</p><ol><li>对http协议进行封装，简化web程序开发。</li><li>部署web项目，对外提供网上信息浏览服务。</li><li>常用的web服务器软件：Tomcat、Jetty、WebLogic</li></ol><h4 id="_9-1-1-服务器概述" tabindex="-1">9.1.1 服务器概述 <a class="header-anchor" href="#_9-1-1-服务器概述" aria-label="Permalink to &quot;9.1.1 服务器概述&quot;">​</a></h4><p><strong>服务器硬件</strong> 💻</p><ul><li>指的也是计算机，只不过服务器要比我们日常使用的计算机大很多。</li></ul><p><img src="'+Ya+'" alt="image-20221202173148317"></p><p>服务器，也称伺服器。是提供计算服务的设备。由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力。</p><p>服务器的构成包括处理器、硬盘、内存、系统总线等，和通用的计算机架构类似，但是由于需要提供高可靠的服务，因此在处理能力、稳定性、可靠性、安全性、可扩展性、可管理性等方面要求较高。</p><p>在网络环境下，根据服务器提供的服务类型不同，可分为：文件服务器，数据库服务器，应用程序服务器，WEB服务器等。</p><p>服务器只是一台设备，必须安装服务器软件才能提供相应的服务。</p><p><strong>服务器软件</strong> 💿</p><p>服务器软件：基于ServerSocket编写的程序</p><ul><li>服务器软件本质是一个运行在服务器设备上的应用程序</li><li>能够接收客户端请求，并根据请求给客户端响应数据</li></ul><p><img src="'+Xa+'" alt="1530625192392"></p><p>1530625192392</p><h4 id="_9-1-2-web服务器-🍐" tabindex="-1">9.1.2 Web服务器 🍐 <a class="header-anchor" href="#_9-1-2-web服务器-🍐" aria-label="Permalink to &quot;9.1.2 Web服务器 🍐&quot;">​</a></h4><p>Web服务器是一个应用程序(软件)，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作(不用程序员自己写代码去解析http协议规则)，让Web开发更加便捷。主要功能是&quot;提供网上信息浏览服务&quot;。</p><p><img src="'+za+'" alt=""></p><p>Web服务器是安装在服务器端的一款软件，将来我们把自己写的Web项目部署到Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。</p><p>Web服务器软件使用步骤</p><ul><li>准备静态资源</li><li>下载安装Web服务器软件</li><li>将静态资源部署到Web服务器上</li><li>启动Web服务器使用浏览器访问对应的资源</li></ul><p>第1步：准备静态资源</p><ul><li>在提供的资料中找到静态资源文件</li></ul><p><img src="'+Za+'" alt="image-20221202180119859"></p><p>第2步：下载安装Web服务器软件</p><p><img src="'+Qa+'" alt="image-20221202181110555"></p><p>第3步：将静态资源部署到Web服务器上</p><p><img src="'+$a+'" alt="image-20221202180805686"></p><p>第4步：启动Web服务器使用浏览器访问对应的资源</p><p><img src="'+as+'" alt="image-20221202181346327"></p><p>浏览器输入：<code>http://localhost:8080/demo/index.html</code></p><p><img src="'+ss+'" alt="image-20221202181651469"></p><p>上述内容在演示的时候，使用的是Apache下的Tomcat软件，至于Tomcat软件如何使用，后面会详细的讲到。而对于Web服务器来说，实现的方案有很多，Tomcat只是其中的一种，而除了Tomcat以外，还有很多优秀的Web服务器，比如:</p><p><img src="'+ps+'" alt="image-20220824233728524"></p><p>技巧</p><p>Tomcat就是一款软件，我们主要是以学习如何去使用为主。具体我们会从以下这些方向去学习:</p><ol><li>简介：初步认识下Tomcat 🍐</li><li>基本使用: 安装、卸载、启动、关闭、配置和项目部署，这些都是对Tomcat的基本操作 🍐</li><li>IDEA中如何创建Maven Web项目 ❤️</li><li>IDEA中如何使用Tomcat ❤️</li></ol><h4 id="_9-1-3-tomcat" tabindex="-1">9.1.3 Tomcat <a class="header-anchor" href="#_9-1-3-tomcat" aria-label="Permalink to &quot;9.1.3 Tomcat&quot;">​</a></h4><p>Tomcat服务器软件是一个免费的开源的web应用服务器。是Apache软件基金会的一个核心项目。由Apache，Sun和其他一些公司及个人共同开发而成。</p><p>由于Tomcat只支持Servlet/JSP少量JavaEE规范，所以是一个开源免费的轻量级Web服务器。</p><blockquote><p>JavaEE规范： JavaEE =&gt; Java Enterprise Edition(Java企业版)</p><p>avaEE规范就是指Java企业级开发的技术规范总和。包含13项技术规范：JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、JAF</p></blockquote><p>因为Tomcat支持Servlet/JSP规范，所以Tomcat也被称为Web容器、Servlet容器。JavaWeb程序需要依赖Tomcat才能运行。</p><p>Tomcat的官网: <a href="https://tomcat.apache.org/" target="_blank" rel="noreferrer">https://tomcat.apache.org/open in new window</a></p><p><img src="'+ns+'" alt="image-20220824233903517"></p><h3 id="_9-2-基本使用-🚀" tabindex="-1">9.2 基本使用 🚀 <a class="header-anchor" href="#_9-2-基本使用-🚀" aria-label="Permalink to &quot;9.2 基本使用 🚀&quot;">​</a></h3><h4 id="_9-2-2-安装与卸载" tabindex="-1">9.2.2 安装与卸载 <a class="header-anchor" href="#_9-2-2-安装与卸载" aria-label="Permalink to &quot;9.2.2 安装与卸载&quot;">​</a></h4><p><strong>安装:</strong> Tomcat是绿色版，直接解压即安装</p><blockquote><p>在E盘的develop目录下，将<code>apache-tomcat-9.0.27-windows-x64.zip</code>进行解压缩，会得到一个<code>apache-tomcat-9.0.27</code>的目录，Tomcat就已经安装成功。</p></blockquote><p><img src="'+ts+'" alt="image-20221202184545321"></p><p>注意，Tomcat在解压缩的时候，解压所在的目录可以任意，但最好解压到一个不包含中文和空格的目录，因为后期在部署项目的时候，如果路径有中文或者空格可能会导致程序部署失败。</p><p>打开<code>apache-tomcat-9.0.27</code>目录就能看到如下目录结构，每个目录中包含的内容需要认识下</p><p><img src="'+es+'" alt=""></p><p>bin：目录下有两类文件，一种是以<code>.bat</code>结尾的，是Windows系统的可执行文件，一种是以<code>.sh</code>结尾的，是Linux系统的可执行文件。</p><p>webapps：就是以后项目部署的目录</p><p>**卸载：**卸载比较简单，可以直接删除目录即可</p><h4 id="_9-2-3-启动与关闭" tabindex="-1">9.2.3 启动与关闭 <a class="header-anchor" href="#_9-2-3-启动与关闭" aria-label="Permalink to &quot;9.2.3 启动与关闭&quot;">​</a></h4><p><strong>启动Tomcat</strong></p><ul><li>双击tomcat解压目录/bin/<strong>startup.bat</strong>文件即可启动tomcat</li></ul><p><img src="'+ls+'" alt="image-20221202183201663"></p><p>注意: tomcat服务器启动后,黑窗口不会关闭,只要黑窗口不关闭,就证明tomcat服务器正在运行</p><p><img src="'+is+'" alt="image-20221202183409304"></p><p>Tomcat的默认端口为8080，所以在浏览器的地址栏输入：<code>http://127.0.0.1:8080</code> 即可访问tomcat服务器</p><blockquote><p>127.0.0.1 也可以使用localhost代替。如：<code>http://localhost:8080</code></p></blockquote><p><img src="'+os+'" alt="image-20221202183550682"></p><ul><li>能看到以上图片中Apache Tomcat的内容就说明Tomcat已经启动成功</li></ul><p>注意事项 ：Tomcat启动的过程中，遇到控制台有中文乱码时，可以通常修改conf/logging.prooperties文件解决</p><p><img src="'+rs+'" alt="image-20220825083848086"></p><p><strong>关闭:</strong> 关闭有三种方式</p><p>1、强制关闭：直接x掉Tomcat窗口（不建议）</p><p><img src="'+cs+'" alt="image-20221202184753808"></p><p>2、正常关闭：bin\\shutdown.bat</p><p><img src="'+gs+'" alt="image-20221202185103941"></p><p>3、正常关闭：在Tomcat启动窗口中按下 Ctrl+C</p><ul><li>说明：如果按下Ctrl+C没有反映，可以多按几次</li></ul><h4 id="_9-2-4-常见问题" tabindex="-1">9.2.4 常见问题 <a class="header-anchor" href="#_9-2-4-常见问题" aria-label="Permalink to &quot;9.2.4 常见问题&quot;">​</a></h4><p><strong>问题1：Tomcat启动时，窗口一闪而过</strong></p><ul><li>检查JAVA_HOME环境变量是否正确配置</li></ul><p><img src="'+ms+'" alt="image-20221202190033167"></p><p><strong>问题2：端口号冲突</strong></p><p><img src="'+ds+'" alt="image-20220825084104447"></p><ul><li><p>发生问题的原因：Tomcat使用的端口被占用了。</p></li><li><p>解决方案：换Tomcat端口号</p><ul><li>要想修改Tomcat启动的端口号，需要修改 conf/server.xml文件</li></ul></li></ul><p><img src="'+hs+'" alt="image-20220825084017185"></p><blockquote><p>注: HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。</p></blockquote><h3 id="_9-3-入门程序解析-🍐" tabindex="-1">9.3 入门程序解析 🍐 <a class="header-anchor" href="#_9-3-入门程序解析-🍐" aria-label="Permalink to &quot;9.3 入门程序解析 🍐&quot;">​</a></h3><p>问题</p><ol><li>为何SpringBoot工程如此强大？起步依赖名字有什么特点？</li></ol><p>点击查看代码</p><ol><li>因为有一个强大的父工程</li><li>起步依赖的名字中包含 <code>starter</code>单词</li></ol><p>关于web开发的基础知识，我们可以告一段落了。下面呢，我们在基于今天的核心技术点SpringBoot快速入门案例进行分析。</p><h4 id="_9-3-1-spring官方骨架" tabindex="-1">9.3.1 Spring官方骨架 <a class="header-anchor" href="#_9-3-1-spring官方骨架" aria-label="Permalink to &quot;9.3.1 Spring官方骨架&quot;">​</a></h4><p>之前我们创建的SpringBoot入门案例，是基于Spring官方提供的骨架实现的。</p><p>Spring官方骨架，可以理解为Spring官方为程序员提供一个搭建项目的模板。</p><blockquote><p>如果卡顿，可以使用Custom 香港的地址：<a href="https://start.springboot.io/" target="_blank" rel="noreferrer">https://start.springboot.ioopen in new window</a></p></blockquote><p><img src="'+us+'" alt="image-20221202195646621"></p><p>我们可以通过访问：<a href="https://start.spring.io/" target="_blank" rel="noreferrer">https://start.spring.io/open in new window</a> ，进入到官方骨架页面</p><p><img src="'+_s+'" alt="image-20221202201623424"></p><p><img src="'+bs+'" alt="image-20221202200356398"></p><p><img src="'+vs+'" alt="image-20221202200547676"></p><p><img src="'+qs+'" alt="image-20221202200708988"></p><p>Spring官方生成的SpringBoot项目，怎么使用呢？</p><ul><li>解压缩后，就会得到一个SpringBoot项目工程</li></ul><p><img src="'+ks+'" alt="image-20221202201042109"></p><p><img src="'+fs+'" alt="image-20221202201221136"></p><p>打开pom.xml文件，我们可以看到springboot项目中引入了web依赖和test依赖</p><p><img src="'+Ts+'" alt="image-20221202201826364"></p><p>技巧</p><p>不论使用IDEA创建SpringBoot项目，还是直接在官方网站利用骨架生成SpringBoot项目，项目的结构和pom.xml文件中内容是相似的。</p><h4 id="_9-3-2-起步依赖" tabindex="-1">9.3.2 起步依赖 <a class="header-anchor" href="#_9-3-2-起步依赖" aria-label="Permalink to &quot;9.3.2 起步依赖&quot;">​</a></h4><p>在我们之前讲解的SpringBoot快速入门案例中，同样也引用了：web依赖和test依赖</p><p><img src="'+Ss+'" alt="image-20221202202305118"></p><p>spring-boot-starter-web和spring-boot-starter-test，在SpringBoot中又称为：起步依赖</p><p>而在SpringBoot的项目中，有很多的起步依赖，他们有一个共同的特征：就是以<code>spring-boot-starter-</code>作为开头。在以后大家遇到spring-boot-starter-xxx这类的依赖，都为起步依赖。</p><p>起步依赖有什么特殊之处呢，这里我们以入门案例中引入的起步依赖做为讲解：</p><ul><li>spring-boot-starter-web：包含了web应用开发所需要的常见依赖</li><li>spring-boot-starter-test：包含了单元测试所需要的常见依赖</li></ul><blockquote><p><strong>spring-boot-starter-web</strong>内部把关于Web开发所有的依赖都已经导入并且指定了版本，只需引入 <code>spring-boot-starter-web</code> 依赖就可以实现Web开发的需要的功能</p><p><img src="'+ws+'" alt="image-20221202204013113"></p><p>image-20221202204013113</p></blockquote><p>Spring的官方提供了很多现成的starter(起步依赖)，我们在开发相关应用时，只需要引入对应的starter即可。</p><p>官方地址：<a href="https://docs.spring.io/spring-boot/docs/2.7.2/reference/htmlsingle/#using.build-systems.starters" target="_blank" rel="noreferrer">https://docs.spring.io/spring-boot/docs/2.7.2/reference/htmlsingle/#using.build-systems.startersopen in new window</a></p><p><img src="'+Ps+'" alt="image-20221202204536647"></p><p>每一个起步依赖，都用于开发一个特定的功能。</p><blockquote><p>举例：当我们开发中需要使用redis数据库时，只需要在SpringBoot项目中，引入：spring-boot-starter-redis ，即可导入redis开发所需要的依赖。</p></blockquote><h4 id="_9-3-2-springboot父工程" tabindex="-1">9.3.2 SpringBoot父工程 <a class="header-anchor" href="#_9-3-2-springboot父工程" aria-label="Permalink to &quot;9.3.2 SpringBoot父工程&quot;">​</a></h4><p>在我们之前开发的SpringBoot入门案例中，我们通过maven引入的依赖，是没有指定具体的依赖版本号的。</p><p><img src="'+Ms+'" alt="image-20221202205103486"></p><p>问题</p><ol><li>为什么没有指定<code>&lt;version&gt;</code>版本号，可以正常使用呢？</li></ol><p>点击查看</p><ul><li>因为每一个SpringBoot工程，都有一个父工程。依赖的版本号，在父工程中统一管理。</li></ul><p><img src="'+xs+'" alt="image-20221202205318778"></p><h4 id="_9-3-3-内嵌tomcat" tabindex="-1">9.3.3 内嵌Tomcat <a class="header-anchor" href="#_9-3-3-内嵌tomcat" aria-label="Permalink to &quot;9.3.3 内嵌Tomcat&quot;">​</a></h4><p>问题</p><ol><li>为什么我们之前书写的SpringBoot入门程序中，并没有把程序部署到Tomcat的webapps目录下，也可以运行呢？</li></ol><p>点击查看</p><p>是因为在我们的SpringBoot中，引入了web运行环境(也就是引入spring-boot-starter-web起步依赖)，其内部已经集成了内置的Tomcat服务器。</p><p>我们可以通过IDEA开发工具右侧的maven面板中，就可以看到当前工程引入的依赖。其中已经将Tomcat的相关依赖传递下来了，也就是说在SpringBoot中可以直接使用Tomcat服务器。</p><p><img src="'+Bs+'" alt=""></p><p>当我们运行SpringBoot的引导类时(运行main方法)，就会看到命令行输出的日志，其中占用8080端口的就是Tomcat。</p><p><img src="'+js+'" alt="image-20220825195359993"></p>',605),ys=[Ds];function Es(Hs,As,Is,Os,Ws,Js){return t(),n("div",null,ys)}const Us=p(Cs,[["render",Es]]);export{Rs as __pageData,Us as default};
